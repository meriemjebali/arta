{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Arta documentation","text":"<p>Arta is a very simple python rules engine designed for and by python developers.</p> <ul> <li>Want to discover what is Arta?  Get Started</li> <li>Want to know how to use it?  User Guide</li> </ul> <p>New feature</p> <p>Check out the new and very convenient feature called the simple condition. A new and lightweight way of configuring your rules' conditions.</p> <p>Arta is automatically tested with:</p> <p></p> <p>Hello World</p> <p>Want to try it very quickly on a very simple use case? Go to the Hello World section.</p> <p>Releases</p> <p>Want to see last updates, check the Release notes </p> <p>Pydantic 2</p> <p>Arta is now working with Pydantic 2! And of course, Pydantic 1 as well.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#_enginepy","title":"_engine.py","text":"<p>Module implementing the rules engine.</p> <p>Class: RulesEngine</p>"},{"location":"api_reference/#arta._engine.RulesEngine","title":"<code>RulesEngine</code>","text":"<p>The Rules Engine is in charge of executing different groups of rules of a given rule set on user input data.</p> <p>Attributes:</p> Name Type Description <code>rules</code> <code>Dict[str, Dict[str, List[Rule]]]</code> <p>A dictionary of rules with k: rule set, v: (k: rule group, v: list of rule instances).</p> Source code in <code>arta/_engine.py</code> <pre><code>class RulesEngine:\n    \"\"\"The Rules Engine is in charge of executing different groups of rules of a given rule set on user input data.\n\n    Attributes:\n        rules:  A dictionary of rules with k: rule set, v: (k: rule group, v: list of rule instances).\n    \"\"\"\n\n    # ==== Class constants ====\n\n    # Rule related config keys\n    CONST_RULE_SETS_CONF_KEY: str = \"rules\"\n    CONST_DFLT_RULE_SET_ID: str = \"default_rule_set\"\n    CONST_STD_RULE_CONDITION_CONF_KEY: str = \"condition\"\n    CONST_ACTION_CONF_KEY: str = \"action\"\n    CONST_ACTION_PARAMETERS_CONF_KEY: str = \"action_parameters\"\n\n    # Condition related config keys\n    CONST_STD_CONDITIONS_CONF_KEY: str = \"conditions\"\n    CONST_CONDITION_VALIDATION_FUNCTION_CONF_KEY: str = \"validation_function\"\n    CONST_CONDITION_DESCRIPTION_CONF_KEY: str = \"description\"\n    CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY: str = \"condition_parameters\"\n    CONST_USER_CONDITION_STRING: str = \"USER_CONDITION\"\n\n    # Built-in factory mapping\n    BUILTIN_FACTORY_MAPPING: Dict[str, Type[BaseCondition]] = {\n        \"condition\": StandardCondition,\n        \"simple_condition\": SimpleCondition,\n    }\n\n    def __init__(\n        self,\n        *,\n        rules_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n        config_path: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Initialize the rules.\n\n        2 possibilities: either 'rules_dict', or 'config_path', not both.\n\n        Args:\n            rules_dict: A dictionary containing the rules' definitions.\n            config_path: Path of a directory containing the YAML files.\n\n        Raises:\n            KeyError: Key not found.\n            TypeError: Wrong type.\n        \"\"\"\n        # Var init.\n        factory_mapping_classes: Dict[str, Type[BaseCondition]] = {}\n        std_condition_instances: Dict[str, StandardCondition] = {}\n\n        if config_path is not None and rules_dict is not None:\n            raise ValueError(\"RulesEngine takes only one parameter: 'rules_dict' or 'config_path', not both.\")\n\n        # Init. default parsing_error_strategy (probably not needed because already defined elsewhere)\n        self._parsing_error_strategy: ParsingErrorStrategy = ParsingErrorStrategy.RAISE\n\n        # Initialize directly with a rules dict\n        if rules_dict is not None:\n            # Data validation\n            RulesDict.parse_obj(rules_dict)\n\n            # Edge cases data validation\n            if not isinstance(rules_dict, dict):\n                raise TypeError(f\"'rules_dict' must be dict type, not '{type(rules_dict)}'\")\n            elif len(rules_dict) == 0:\n                raise KeyError(\"'rules_dict' couldn't be empty.\")\n\n            # Attribute definition\n            self.rules: Dict[str, Dict[str, List[Rule]]] = self._adapt_user_rules_dict(rules_dict)\n\n        # Initialize with a config_path\n        elif config_path is not None:\n            # Load config in attribute\n            config_dict: Dict[str, Any] = load_config(config_path)\n\n            # Data validation\n            config: Configuration = Configuration(**config_dict)\n\n            if config.parsing_error_strategy is not None:\n                # Set parsing error handling strategy from config\n                self._parsing_error_strategy = ParsingErrorStrategy(config.parsing_error_strategy)\n\n            # Dict of available action functions (k: function name, v: function object)\n            action_modules: List[str] = config.actions_source_modules\n            action_functions: Dict[str, Callable] = self._get_object_from_source_modules(action_modules)\n\n            # Dict of available standard condition functions (k: function name, v: function object)\n            condition_modules: List[str] = (\n                config.conditions_source_modules if config.conditions_source_modules is not None else []\n            )\n            std_condition_functions: Dict[str, Callable] = self._get_object_from_source_modules(condition_modules)\n\n            # Dictionary of condition instances (k: condition id, v: instance), built from config data\n            if len(std_condition_functions) &gt; 0:\n                std_condition_instances = self._build_std_conditions(\n                    config=config.dict(), condition_functions_dict=std_condition_functions\n                )\n\n            # User-defined/custom conditions\n            if config.condition_factory_mapping is not None and config.custom_classes_source_modules is not None:\n                # Dict of custom condition classes (k: classe name, v: class object)\n                custom_condition_classes: Dict[str, Type[BaseCondition]] = self._get_object_from_source_modules(\n                    config.custom_classes_source_modules\n                )\n\n                # Build a factory mapping dictionary (k: conf key, v:class object)\n                factory_mapping_classes.update(\n                    {\n                        conf_key: custom_condition_classes[class_name]\n                        for conf_key, class_name in config.condition_factory_mapping.items()\n                    }\n                )\n\n            # Arta built-in conditions\n            factory_mapping_classes.update(self.BUILTIN_FACTORY_MAPPING)\n\n            # Attribute definition\n            self.rules = self._build_rules(\n                std_condition_instances=std_condition_instances,\n                action_functions=action_functions,\n                config=config.dict(),\n                factory_mapping_classes=factory_mapping_classes,\n            )\n        else:\n            raise ValueError(\"RulesEngine needs a parameter: 'rule_dict' or 'config_path'.\")\n\n    def apply_rules(\n        self, input_data: Dict[str, Any], *, rule_set: Optional[str] = None, verbose: bool = False, **kwargs: Any\n    ) -&gt; Dict[str, Any]:\n        \"\"\"Apply the rules and return results.\n\n        For each rule group of a given rule set, rules are applied sequentially,\n        The loop is broken when a rule is applied (an action is triggered).\n        Then, the next rule group is evaluated.\n        And so on...\n\n        This means that the order of the rules in the configuration file\n        (e.g., rules.yaml) is meaningful.\n\n        Args:\n            input_data: Input data to apply rules on.\n            rule_set: Apply rules associated with the specified rule set.\n            verbose: If True, add extra ids (group_id, rule_id) for result explicability.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            A dictionary containing the rule groups' results (k: group id, v: action result).\n\n        Raises:\n            TypeError: Wrong type.\n            KeyError: Key not found.\n        \"\"\"\n        # Input_data validation\n        if not isinstance(input_data, dict):\n            raise TypeError(f\"'input_data' must be dict type, not '{type(input_data)}'\")\n        elif len(input_data) == 0:\n            raise KeyError(\"'input_data' couldn't be empty.\")\n\n        # Var init.\n        input_data_copy: Dict[str, Any] = copy.deepcopy(input_data)\n\n        # Prepare the result key\n        input_data_copy[\"output\"] = {}\n\n        # If there is no given rule set param. and there is only one rule set in self.rules\n        # and its value is 'default_rule_set', look for this one (rule_set='default_rule_set')\n        if rule_set is None and len(self.rules) == 1 and self.rules.get(self.CONST_DFLT_RULE_SET_ID) is not None:\n            rule_set = self.CONST_DFLT_RULE_SET_ID\n\n        # Check if given rule set is in self.rules?\n        if rule_set not in self.rules:\n            raise KeyError(\n                f\"Rule set '{rule_set}' not found in the rules, available rule sets are : {list(self.rules.keys())}.\"\n            )\n\n        # Var init.\n        results_dict: Dict[str, Any] = {\"verbosity\": {\"rule_set\": rule_set, \"results\": []}}\n\n        # Groups' loop\n        for group_id, rules_list in self.rules[rule_set].items():\n            # Initialize result of the rule group with None\n            results_dict[group_id] = None\n\n            # Rules' loop (inside a group)\n            for rule in rules_list:\n                # Apply rules\n                action_result, rule_details = rule.apply(\n                    input_data_copy, parsing_error_strategy=self._parsing_error_strategy, **kwargs\n                )\n\n                # Check if the rule has been applied (= action activated)\n                if \"action_result\" in rule_details:\n                    # Save result and details\n                    results_dict[group_id] = action_result\n                    results_dict[\"verbosity\"][\"results\"].append(rule_details)\n\n                    # Update input data with current result with key 'output' (can be used in next rules)\n                    input_data_copy[\"output\"][group_id] = copy.deepcopy(results_dict[group_id])\n\n                    # We can only have one result per group =&gt; break when \"action_result\" in rule_details\n                    break\n\n        # Handling non-verbose mode\n        if not verbose:\n            results_dict.pop(\"verbosity\")\n\n        return results_dict\n\n    @staticmethod\n    def _get_object_from_source_modules(module_list: List[str]) -&gt; Dict[str, Any]:\n        \"\"\"(Protected)\n        Collect all functions defined in the list of modules.\n\n        Args:\n            module_list: List of source module names.\n\n        Returns:\n            Dictionary with objects found in the modules.\n        \"\"\"\n        object_dict: Dict[str, Any] = {}\n\n        for module_name in module_list:\n            # Import module\n            mod: ModuleType = importlib.import_module(module_name)\n\n            # Collect functions\n            module_functions: Dict[str, Any] = {key: val for key, val in getmembers(mod, isfunction)}\n            object_dict.update(module_functions)\n\n            # Collect classes\n            module_classes: Dict[str, Any] = {key: val for key, val in getmembers(mod, isclass)}\n            object_dict.update(module_classes)\n\n        return object_dict\n\n    def _build_rules(\n        self,\n        std_condition_instances: Dict[str, StandardCondition],\n        action_functions: Dict[str, Callable],\n        config: Dict[str, Any],\n        factory_mapping_classes: Dict[str, Type[BaseCondition]],\n    ) -&gt; Dict[str, Dict[str, List[Any]]]:\n        \"\"\"(Protected)\n        Return a dictionary of Rule instances built from the configuration.\n\n        Args:\n            rule_sets: Sets of rules to be loaded in the Rules Engine (as needed by further uses).\n            std_condition_instances: Dictionary of condition instances (k: condition id, v: StandardCondition instance)\n            actions_dict: Dictionary of action functions (k: action name, v: Callable)\n            config: Dictionary of the imported configuration from yaml files.\n            factory_mapping_classes: A mapping dictionary (k: condition conf. key, v: custom class object)\n\n        Returns:\n            A dictionary of rules.\n        \"\"\"\n        # Var init.\n        rules_dict: Dict[str, Dict[str, List[Any]]] = {}\n\n        # Retrieve rule set ids from config\n        rule_set_ids: List[str] = list(config[self.CONST_RULE_SETS_CONF_KEY].keys())\n\n        # Going all way down to the rules (rule set &gt; rule group &gt; rule)\n        for set_id in rule_set_ids:\n            rules_conf: Dict[str, Any] = config[self.CONST_RULE_SETS_CONF_KEY][set_id]\n            rules_dict[set_id] = {}\n            rule_set_dict: Dict[str, List[Any]] = rules_dict[set_id]\n\n            # Looping throught groups\n            for group_id, group_rules in rules_conf.items():\n                # Initialize list or rules in the group\n                rule_set_dict[group_id] = []\n\n                # Looping through rules (inside a group)\n                for rule_id, rule_dict in group_rules.items():\n                    # Get action function\n                    action_function_name: str = rule_dict[self.CONST_ACTION_CONF_KEY]\n\n                    if action_function_name not in action_functions:\n                        raise KeyError(f\"Unknwown action function : {action_function_name}\")\n\n                    action: Callable = action_functions[action_function_name]\n\n                    # Look for condition conf. keys inside the rule\n                    condition_conf_keys: Set[str] = set(rule_dict.keys()) - {\n                        self.CONST_ACTION_CONF_KEY,\n                        self.CONST_ACTION_PARAMETERS_CONF_KEY,\n                    }\n\n                    # Store the cond. expressions with the same order as in the configuration file (very important)\n                    condition_exprs: Dict[str, Optional[str]] = {\n                        key: value for key, value in rule_dict.items() if key in condition_conf_keys\n                    }\n\n                    # Create the corresponding Rule instance\n                    rule: Rule = Rule(\n                        set_id=set_id,\n                        group_id=group_id,\n                        rule_id=rule_id,\n                        action=action,\n                        action_parameters=rule_dict[self.CONST_ACTION_PARAMETERS_CONF_KEY],\n                        condition_exprs=condition_exprs,\n                        std_condition_instances=std_condition_instances,\n                        condition_factory_mapping=factory_mapping_classes,\n                    )\n                    rule_set_dict[group_id].append(rule)\n\n        return rules_dict\n\n    def _build_std_conditions(\n        self, config: Dict[str, Any], condition_functions_dict: Dict[str, Callable]\n    ) -&gt; Dict[str, StandardCondition]:\n        \"\"\"(Protected)\n        Return a dictionary of Condition instances built from the configuration file.\n\n        Args:\n            config: Dictionary of the imported configuration from yaml files.\n            condition_functions_dict: A dictionary where k:condition id, v:Callable (validation function).\n\n        Returns:\n            A dictionary of StandardCondition instances (k: condition id, v: StandardCondition instance).\n        \"\"\"\n        # Var init.\n        conditions_dict: Dict[str, StandardCondition] = {}\n\n        # Condition configuration (under conditions' key)\n        conditions_conf: Dict[str, Dict[str, Any]] = config[self.CONST_STD_CONDITIONS_CONF_KEY]\n\n        # Looping through conditions (inside a group)\n        for condition_id, condition_params in conditions_conf.items():\n            # Get condition validation function\n            validation_function_name: str = condition_params[self.CONST_CONDITION_VALIDATION_FUNCTION_CONF_KEY]\n\n            if validation_function_name not in condition_functions_dict:\n                raise KeyError(f\"Unknwown validation function : {validation_function_name}\")\n\n            # Get Callable from function name\n            validation_function: Callable = condition_functions_dict[validation_function_name]\n\n            # Create Condition instance\n            condition_instance: StandardCondition = StandardCondition(\n                condition_id=condition_id,\n                description=condition_params[self.CONST_CONDITION_DESCRIPTION_CONF_KEY],\n                validation_function=validation_function,\n                validation_function_parameters=condition_params[self.CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY],\n            )\n            conditions_dict[condition_id] = condition_instance\n\n        return conditions_dict\n\n    def _adapt_user_rules_dict(self, rules_dict: Dict[str, Dict[str, Any]]) -&gt; Dict[str, Dict[str, List[Any]]]:\n        \"\"\"(Protected)\n        Return a dictionary of Rule's instances built from user's rules dictionary.\n\n        Args:\n            rules_dict: User raw rules dictionary.\n\n        Returns:\n            A rules dictionary made from the user input rules.\n        \"\"\"\n        # Var init.\n        rules_dict_formatted: Dict[str, List[Any]] = {}\n\n        # Looping throught groups\n        for group_id, group_rules in rules_dict.items():\n            # Initialize list or rules in the group\n            rules_dict_formatted[group_id] = []\n\n            # Looping through rules (inside a group)\n            for rule_id, rule_dict in group_rules.items():\n                # Get action function\n                action = rule_dict[\"action\"]\n\n                # Trigger if not **kwargs\n                if \"kwargs\" not in inspect.signature(action).parameters:\n                    raise KeyError(f\"The action function {action} must have a '**kwargs' parameter.\")\n\n                # Create Rule instance\n                rule = Rule(\n                    set_id=self.CONST_DFLT_RULE_SET_ID,\n                    group_id=group_id,\n                    rule_id=rule_id,\n                    action=action,\n                    action_parameters=rule_dict.get(self.CONST_ACTION_PARAMETERS_CONF_KEY),\n                    condition_exprs={self.CONST_STD_RULE_CONDITION_CONF_KEY: self.CONST_USER_CONDITION_STRING}\n                    if self.CONST_STD_RULE_CONDITION_CONF_KEY in rule_dict\n                    and rule_dict.get(self.CONST_STD_RULE_CONDITION_CONF_KEY) is not None\n                    else {self.CONST_STD_RULE_CONDITION_CONF_KEY: None},\n                    std_condition_instances={\n                        self.CONST_USER_CONDITION_STRING: StandardCondition(\n                            condition_id=self.CONST_USER_CONDITION_STRING,\n                            description=\"Automatic description\",\n                            validation_function=rule_dict.get(self.CONST_STD_RULE_CONDITION_CONF_KEY),\n                            validation_function_parameters=rule_dict.get(\n                                self.CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY\n                            ),\n                        )\n                    },\n                    condition_factory_mapping=self.BUILTIN_FACTORY_MAPPING,\n                )\n                rules_dict_formatted[group_id].append(rule)\n\n        return {self.CONST_DFLT_RULE_SET_ID: rules_dict_formatted}\n\n    def __str__(self) -&gt; str:\n        \"\"\"Object human string representation (called by str()).\n\n        Returns:\n            A string representation of the instance.\n        \"\"\"\n        # Vars init.\n        attrs_str: str = \"\"\n\n        # Get some instance attributes infos\n        class_name: str = self.__class__.__name__\n        attrs: List[Tuple[str, Any]] = [\n            attr\n            for attr in inspect.getmembers(self)\n            if not (\n                attr[0].startswith(\"_\")\n                or attr[0].startswith(\"CONST_\")\n                or isinstance(attr[1], (FunctionType, MethodType))\n            )\n        ]\n\n        # Build string representation\n        for attr, val in attrs:\n            attrs_str += f\"{attr}={str(val)}, \"\n\n        return f\"{class_name}({attrs_str})\"\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.__init__","title":"<code>__init__(*, rules_dict=None, config_path=None)</code>","text":"<p>Initialize the rules.</p> <p>2 possibilities: either 'rules_dict', or 'config_path', not both.</p> <p>Parameters:</p> Name Type Description Default <code>rules_dict</code> <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>A dictionary containing the rules' definitions.</p> <code>None</code> <code>config_path</code> <code>Optional[str]</code> <p>Path of a directory containing the YAML files.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>Key not found.</p> <code>TypeError</code> <p>Wrong type.</p> Source code in <code>arta/_engine.py</code> <pre><code>def __init__(\n    self,\n    *,\n    rules_dict: Optional[Dict[str, Dict[str, Any]]] = None,\n    config_path: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Initialize the rules.\n\n    2 possibilities: either 'rules_dict', or 'config_path', not both.\n\n    Args:\n        rules_dict: A dictionary containing the rules' definitions.\n        config_path: Path of a directory containing the YAML files.\n\n    Raises:\n        KeyError: Key not found.\n        TypeError: Wrong type.\n    \"\"\"\n    # Var init.\n    factory_mapping_classes: Dict[str, Type[BaseCondition]] = {}\n    std_condition_instances: Dict[str, StandardCondition] = {}\n\n    if config_path is not None and rules_dict is not None:\n        raise ValueError(\"RulesEngine takes only one parameter: 'rules_dict' or 'config_path', not both.\")\n\n    # Init. default parsing_error_strategy (probably not needed because already defined elsewhere)\n    self._parsing_error_strategy: ParsingErrorStrategy = ParsingErrorStrategy.RAISE\n\n    # Initialize directly with a rules dict\n    if rules_dict is not None:\n        # Data validation\n        RulesDict.parse_obj(rules_dict)\n\n        # Edge cases data validation\n        if not isinstance(rules_dict, dict):\n            raise TypeError(f\"'rules_dict' must be dict type, not '{type(rules_dict)}'\")\n        elif len(rules_dict) == 0:\n            raise KeyError(\"'rules_dict' couldn't be empty.\")\n\n        # Attribute definition\n        self.rules: Dict[str, Dict[str, List[Rule]]] = self._adapt_user_rules_dict(rules_dict)\n\n    # Initialize with a config_path\n    elif config_path is not None:\n        # Load config in attribute\n        config_dict: Dict[str, Any] = load_config(config_path)\n\n        # Data validation\n        config: Configuration = Configuration(**config_dict)\n\n        if config.parsing_error_strategy is not None:\n            # Set parsing error handling strategy from config\n            self._parsing_error_strategy = ParsingErrorStrategy(config.parsing_error_strategy)\n\n        # Dict of available action functions (k: function name, v: function object)\n        action_modules: List[str] = config.actions_source_modules\n        action_functions: Dict[str, Callable] = self._get_object_from_source_modules(action_modules)\n\n        # Dict of available standard condition functions (k: function name, v: function object)\n        condition_modules: List[str] = (\n            config.conditions_source_modules if config.conditions_source_modules is not None else []\n        )\n        std_condition_functions: Dict[str, Callable] = self._get_object_from_source_modules(condition_modules)\n\n        # Dictionary of condition instances (k: condition id, v: instance), built from config data\n        if len(std_condition_functions) &gt; 0:\n            std_condition_instances = self._build_std_conditions(\n                config=config.dict(), condition_functions_dict=std_condition_functions\n            )\n\n        # User-defined/custom conditions\n        if config.condition_factory_mapping is not None and config.custom_classes_source_modules is not None:\n            # Dict of custom condition classes (k: classe name, v: class object)\n            custom_condition_classes: Dict[str, Type[BaseCondition]] = self._get_object_from_source_modules(\n                config.custom_classes_source_modules\n            )\n\n            # Build a factory mapping dictionary (k: conf key, v:class object)\n            factory_mapping_classes.update(\n                {\n                    conf_key: custom_condition_classes[class_name]\n                    for conf_key, class_name in config.condition_factory_mapping.items()\n                }\n            )\n\n        # Arta built-in conditions\n        factory_mapping_classes.update(self.BUILTIN_FACTORY_MAPPING)\n\n        # Attribute definition\n        self.rules = self._build_rules(\n            std_condition_instances=std_condition_instances,\n            action_functions=action_functions,\n            config=config.dict(),\n            factory_mapping_classes=factory_mapping_classes,\n        )\n    else:\n        raise ValueError(\"RulesEngine needs a parameter: 'rule_dict' or 'config_path'.\")\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.__str__","title":"<code>__str__()</code>","text":"<p>Object human string representation (called by str()).</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the instance.</p> Source code in <code>arta/_engine.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Object human string representation (called by str()).\n\n    Returns:\n        A string representation of the instance.\n    \"\"\"\n    # Vars init.\n    attrs_str: str = \"\"\n\n    # Get some instance attributes infos\n    class_name: str = self.__class__.__name__\n    attrs: List[Tuple[str, Any]] = [\n        attr\n        for attr in inspect.getmembers(self)\n        if not (\n            attr[0].startswith(\"_\")\n            or attr[0].startswith(\"CONST_\")\n            or isinstance(attr[1], (FunctionType, MethodType))\n        )\n    ]\n\n    # Build string representation\n    for attr, val in attrs:\n        attrs_str += f\"{attr}={str(val)}, \"\n\n    return f\"{class_name}({attrs_str})\"\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.apply_rules","title":"<code>apply_rules(input_data, *, rule_set=None, verbose=False, **kwargs)</code>","text":"<p>Apply the rules and return results.</p> <p>For each rule group of a given rule set, rules are applied sequentially, The loop is broken when a rule is applied (an action is triggered). Then, the next rule group is evaluated. And so on...</p> <p>This means that the order of the rules in the configuration file (e.g., rules.yaml) is meaningful.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Dict[str, Any]</code> <p>Input data to apply rules on.</p> required <code>rule_set</code> <code>Optional[str]</code> <p>Apply rules associated with the specified rule set.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, add extra ids (group_id, rule_id) for result explicability.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary containing the rule groups' results (k: group id, v: action result).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Wrong type.</p> <code>KeyError</code> <p>Key not found.</p> Source code in <code>arta/_engine.py</code> <pre><code>def apply_rules(\n    self, input_data: Dict[str, Any], *, rule_set: Optional[str] = None, verbose: bool = False, **kwargs: Any\n) -&gt; Dict[str, Any]:\n    \"\"\"Apply the rules and return results.\n\n    For each rule group of a given rule set, rules are applied sequentially,\n    The loop is broken when a rule is applied (an action is triggered).\n    Then, the next rule group is evaluated.\n    And so on...\n\n    This means that the order of the rules in the configuration file\n    (e.g., rules.yaml) is meaningful.\n\n    Args:\n        input_data: Input data to apply rules on.\n        rule_set: Apply rules associated with the specified rule set.\n        verbose: If True, add extra ids (group_id, rule_id) for result explicability.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        A dictionary containing the rule groups' results (k: group id, v: action result).\n\n    Raises:\n        TypeError: Wrong type.\n        KeyError: Key not found.\n    \"\"\"\n    # Input_data validation\n    if not isinstance(input_data, dict):\n        raise TypeError(f\"'input_data' must be dict type, not '{type(input_data)}'\")\n    elif len(input_data) == 0:\n        raise KeyError(\"'input_data' couldn't be empty.\")\n\n    # Var init.\n    input_data_copy: Dict[str, Any] = copy.deepcopy(input_data)\n\n    # Prepare the result key\n    input_data_copy[\"output\"] = {}\n\n    # If there is no given rule set param. and there is only one rule set in self.rules\n    # and its value is 'default_rule_set', look for this one (rule_set='default_rule_set')\n    if rule_set is None and len(self.rules) == 1 and self.rules.get(self.CONST_DFLT_RULE_SET_ID) is not None:\n        rule_set = self.CONST_DFLT_RULE_SET_ID\n\n    # Check if given rule set is in self.rules?\n    if rule_set not in self.rules:\n        raise KeyError(\n            f\"Rule set '{rule_set}' not found in the rules, available rule sets are : {list(self.rules.keys())}.\"\n        )\n\n    # Var init.\n    results_dict: Dict[str, Any] = {\"verbosity\": {\"rule_set\": rule_set, \"results\": []}}\n\n    # Groups' loop\n    for group_id, rules_list in self.rules[rule_set].items():\n        # Initialize result of the rule group with None\n        results_dict[group_id] = None\n\n        # Rules' loop (inside a group)\n        for rule in rules_list:\n            # Apply rules\n            action_result, rule_details = rule.apply(\n                input_data_copy, parsing_error_strategy=self._parsing_error_strategy, **kwargs\n            )\n\n            # Check if the rule has been applied (= action activated)\n            if \"action_result\" in rule_details:\n                # Save result and details\n                results_dict[group_id] = action_result\n                results_dict[\"verbosity\"][\"results\"].append(rule_details)\n\n                # Update input data with current result with key 'output' (can be used in next rules)\n                input_data_copy[\"output\"][group_id] = copy.deepcopy(results_dict[group_id])\n\n                # We can only have one result per group =&gt; break when \"action_result\" in rule_details\n                break\n\n    # Handling non-verbose mode\n    if not verbose:\n        results_dict.pop(\"verbosity\")\n\n    return results_dict\n</code></pre>"},{"location":"api_reference/#conditionpy","title":"condition.py","text":"<p>Condition implementation.</p> <p>Classes: BaseCondition, StandardCondition, SimpleCondition</p>"},{"location":"api_reference/#arta.condition.BaseCondition","title":"<code>BaseCondition</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class of a Condition object (Strategy Pattern).</p> <p>Is an abstract class and can't be instantiated.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class BaseCondition(ABC):\n    \"\"\"Base class of a Condition object (Strategy Pattern).\n\n    Is an abstract class and can't be instantiated.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    # Class constants\n    CONST_CONDITION_DATA_LABEL: str = \"Custom condition data (not needed)\"\n    CONDITION_ID_PATTERN: str = UPPERCASE_WORD_PATTERN\n\n    def __init__(\n        self,\n        condition_id: str,\n        description: str,\n        validation_function: Optional[Callable] = None,\n        validation_function_parameters: Optional[Dict[str, Any]] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize attributes.\n\n        Args:\n            condition_id: Id of a condition.\n            description: Description of a condition.\n            validation_function: Validation function of a condition.\n            validation_function_parameters: Arguments of the validation function.\n        \"\"\"\n        self._condition_id = condition_id  # NOSONAR\n        self._description = description  # NOSONAR\n        self._validation_function = validation_function  # NOSONAR\n        self._validation_function_parameters = validation_function_parameters  # NOSONAR\n\n    @classmethod\n    def extract_condition_ids_from_expression(cls, condition_expr: Optional[str] = None) -&gt; Set[str]:\n        \"\"\"Get the condition ids from a string (e.g., UPPERCASE words).\n\n        E.g., CONDITION_1 and not CONDITION_2\n\n        Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.\n\n        Args:\n            condition_expr: A boolean expression (string).\n\n        Returns:\n            A set of extracted condition ids.\n        \"\"\"\n        cond_ids: Set[str] = set()\n\n        if condition_expr is not None:\n            cond_ids = set(re.findall(cls.CONDITION_ID_PATTERN, condition_expr))\n\n        return cond_ids\n\n    @abstractmethod\n    def verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"(Abstract)\n        Return True if the condition is verified.\n\n        Args:\n            input_data: Input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.__init__","title":"<code>__init__(condition_id, description, validation_function=None, validation_function_parameters=None)</code>","text":"<p>Initialize attributes.</p> <p>Parameters:</p> Name Type Description Default <code>condition_id</code> <code>str</code> <p>Id of a condition.</p> required <code>description</code> <code>str</code> <p>Description of a condition.</p> required <code>validation_function</code> <code>Optional[Callable]</code> <p>Validation function of a condition.</p> <code>None</code> <code>validation_function_parameters</code> <code>Optional[Dict[str, Any]]</code> <p>Arguments of the validation function.</p> <code>None</code> Source code in <code>arta/condition.py</code> <pre><code>def __init__(\n    self,\n    condition_id: str,\n    description: str,\n    validation_function: Optional[Callable] = None,\n    validation_function_parameters: Optional[Dict[str, Any]] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize attributes.\n\n    Args:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n    self._condition_id = condition_id  # NOSONAR\n    self._description = description  # NOSONAR\n    self._validation_function = validation_function  # NOSONAR\n    self._validation_function_parameters = validation_function_parameters  # NOSONAR\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.extract_condition_ids_from_expression","title":"<code>extract_condition_ids_from_expression(condition_expr=None)</code>  <code>classmethod</code>","text":"<p>Get the condition ids from a string (e.g., UPPERCASE words).</p> <p>E.g., CONDITION_1 and not CONDITION_2</p> <p>Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.</p> <p>Parameters:</p> Name Type Description Default <code>condition_expr</code> <code>Optional[str]</code> <p>A boolean expression (string).</p> <code>None</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>A set of extracted condition ids.</p> Source code in <code>arta/condition.py</code> <pre><code>@classmethod\ndef extract_condition_ids_from_expression(cls, condition_expr: Optional[str] = None) -&gt; Set[str]:\n    \"\"\"Get the condition ids from a string (e.g., UPPERCASE words).\n\n    E.g., CONDITION_1 and not CONDITION_2\n\n    Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.\n\n    Args:\n        condition_expr: A boolean expression (string).\n\n    Returns:\n        A set of extracted condition ids.\n    \"\"\"\n    cond_ids: Set[str] = set()\n\n    if condition_expr is not None:\n        cond_ids = set(re.findall(cls.CONDITION_ID_PATTERN, condition_expr))\n\n    return cond_ids\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>(Abstract) Return True if the condition is verified.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Dict[str, Any]</code> <p>Input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> Source code in <code>arta/condition.py</code> <pre><code>@abstractmethod\ndef verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"(Abstract)\n    Return True if the condition is verified.\n\n    Args:\n        input_data: Input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#arta.condition.SimpleCondition","title":"<code>SimpleCondition</code>","text":"<p>             Bases: <code>BaseCondition</code></p> <p>Class implementing a built-in simple condition.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class SimpleCondition(BaseCondition):\n    \"\"\"Class implementing a built-in simple condition.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    # Class constants\n    CONST_CUSTOM_CONDITION_DATA_LABEL: str = \"Simple condition data (not needed)\"\n    CONDITION_ID_PATTERN: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-0-9!=&lt;&gt;\\\"NTF\\.]*)\"\n\n    def verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"Return True if the condition is verified.\n\n        Example of a unitary simple condition to be verified: 'input.age&gt;=100'\n\n        Args:\n            input_data: Request or input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n\n        Raises:\n            AttributeError: Check the validation function or its parameters.\n        \"\"\"\n        bool_var: bool = False\n        unitary_expr: str = self._condition_id\n\n        data_path_patt: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-\\.]*)\"\n\n        # Retrieve only the data path\n        path_matches: List[str] = re.findall(data_path_patt, unitary_expr)\n\n        if len(path_matches) == 1:\n            # Regular case: we have a data_path\n            data_path: str = path_matches[0]\n\n            # Read data from its path\n            data = parse_dynamic_parameter(  # noqa\n                parameter=data_path, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n            )\n\n            # Replace with the variable name in the expression\n            eval_expr: str = unitary_expr.replace(data_path, \"data\")\n\n            # Evaluate the expression\n            try:\n                bool_var = eval(eval_expr)  # noqa\n            except TypeError:\n                # Ignore evaluation --&gt; False\n                pass\n\n        elif parsing_error_strategy == ParsingErrorStrategy.RAISE:\n            # Raise an error because of no match for a data path\n            raise ConditionExecutionError(f\"Error when verifying simple condition: '{unitary_expr}'\")\n\n        else:\n            # Other case: ignore, default value =&gt; return False\n            pass\n\n        return bool_var\n</code></pre>"},{"location":"api_reference/#arta.condition.SimpleCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>","text":"<p>Return True if the condition is verified.</p> <p>Example of a unitary simple condition to be verified: 'input.age&gt;=100'</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Dict[str, Any]</code> <p>Request or input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Check the validation function or its parameters.</p> Source code in <code>arta/condition.py</code> <pre><code>def verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"Return True if the condition is verified.\n\n    Example of a unitary simple condition to be verified: 'input.age&gt;=100'\n\n    Args:\n        input_data: Request or input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n\n    Raises:\n        AttributeError: Check the validation function or its parameters.\n    \"\"\"\n    bool_var: bool = False\n    unitary_expr: str = self._condition_id\n\n    data_path_patt: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-\\.]*)\"\n\n    # Retrieve only the data path\n    path_matches: List[str] = re.findall(data_path_patt, unitary_expr)\n\n    if len(path_matches) == 1:\n        # Regular case: we have a data_path\n        data_path: str = path_matches[0]\n\n        # Read data from its path\n        data = parse_dynamic_parameter(  # noqa\n            parameter=data_path, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n        )\n\n        # Replace with the variable name in the expression\n        eval_expr: str = unitary_expr.replace(data_path, \"data\")\n\n        # Evaluate the expression\n        try:\n            bool_var = eval(eval_expr)  # noqa\n        except TypeError:\n            # Ignore evaluation --&gt; False\n            pass\n\n    elif parsing_error_strategy == ParsingErrorStrategy.RAISE:\n        # Raise an error because of no match for a data path\n        raise ConditionExecutionError(f\"Error when verifying simple condition: '{unitary_expr}'\")\n\n    else:\n        # Other case: ignore, default value =&gt; return False\n        pass\n\n    return bool_var\n</code></pre>"},{"location":"api_reference/#arta.condition.StandardCondition","title":"<code>StandardCondition</code>","text":"<p>             Bases: <code>BaseCondition</code></p> <p>Class implementing a built-in condition, named standard condition.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class StandardCondition(BaseCondition):\n    \"\"\"Class implementing a built-in condition, named standard condition.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    def verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"Return True if the condition is verified.\n\n        Example of a unitary standard condition: CONDITION_1\n\n        Args:\n            input_data: Request or input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n\n        Raises:\n            AttributeError: Check the validation function or its parameters.\n        \"\"\"\n        if self._validation_function is None:\n            raise AttributeError(\"Validation function should not be None\")\n\n        if self._validation_function_parameters is None:\n            raise AttributeError(\"Validation function parameters should not be None\")\n\n        # Parse dynamic parameters\n        parameters: Dict[str, Any] = {}\n\n        for key, value in self._validation_function_parameters.items():\n            parameters[key] = parse_dynamic_parameter(\n                parameter=value, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n            )\n\n        # Run validation_function\n        return self._validation_function(**parameters)\n</code></pre>"},{"location":"api_reference/#arta.condition.StandardCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>","text":"<p>Return True if the condition is verified.</p> <p>Example of a unitary standard condition: CONDITION_1</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>Dict[str, Any]</code> <p>Request or input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Check the validation function or its parameters.</p> Source code in <code>arta/condition.py</code> <pre><code>def verify(self, input_data: Dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"Return True if the condition is verified.\n\n    Example of a unitary standard condition: CONDITION_1\n\n    Args:\n        input_data: Request or input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n\n    Raises:\n        AttributeError: Check the validation function or its parameters.\n    \"\"\"\n    if self._validation_function is None:\n        raise AttributeError(\"Validation function should not be None\")\n\n    if self._validation_function_parameters is None:\n        raise AttributeError(\"Validation function parameters should not be None\")\n\n    # Parse dynamic parameters\n    parameters: Dict[str, Any] = {}\n\n    for key, value in self._validation_function_parameters.items():\n        parameters[key] = parse_dynamic_parameter(\n            parameter=value, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n        )\n\n    # Run validation_function\n    return self._validation_function(**parameters)\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":"Concept Definition action A task which is executed when conditions are verified. action function A callable object called to execute the action. action parameter Parameter of an action function. condition A condition to be verified before executing an action. condition id Identifier of a single condition (must be in CAPITAL LETTER). condition expression A boolean expression combining several conditions (meaning several condition id). condition function A callable object called to be verified therefore it returns a boolean. condition parameter Parameter of a condition/validation function. custom condition A user-defined condition. rule A set of conditions combined to one action. rule group A group of rules (usually sharing a common context). rule id Identifier of a single rule. rule set A set of rule groups (mostly one: <code>default_rule_set</code>). simple condition A built-in very simple condition. standard condition The regular built-in condition. validation function Same thing as a condition function."},{"location":"how_to/","title":"How to","text":"<p>Ensure that you have correctly installed Arta before, check the Installation page </p>"},{"location":"how_to/#hello-world","title":"Hello World","text":"<p>You want a simple code to play with? Here it comes:</p> Without type hintsWith type hints (&gt;=3.9) <pre><code>from arta import RulesEngine\n\nset_admission = lambda value, **kwargs: {\"is_admitted\": value}\n\nrules = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n\ninput_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(rules_dict=rules)\n\nresult = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <pre><code>from typing import Any, Callable\n\nfrom arta import RulesEngine\n\nset_admission: Callable = lambda value, **kwargs: {\"is_admitted\": value}\n\nrules: dict[str, Any] = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n\ninput_data: dict[str, Any] = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(rules_dict=rules)\n\nresult: dict[str, Any] = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <p>You should get:</p> <pre><code>{'check_admission': {'is_admitted': True}}\n</code></pre> <p>Success</p> <p>Superman is admitted to the superhero school!</p> <p>Well done! By executing this code you have:</p> <ol> <li>Defined an action function (<code>set_admission</code>)</li> <li>Defined a rule set (<code>rules</code>)</li> <li>Used some input data (<code>input_data</code>)</li> <li>Instanciated a rules engine (<code>RulesEngine</code>)</li> <li>Applied the rules on the data and get some results (<code>.apply_rules()</code>)</li> </ol> <p>Note</p> <p>In the code example we used some anonymous/lambda function for simplicity but it could be regular python functions as well.</p> <p>API Documentation</p> <p>You can get details on the <code>RulesEngine</code> parameters in the API Reference.</p> <p>Have you read the Get Started section? If not, you probably should before going further </p>"},{"location":"how_to/#concepts","title":"Concepts","text":"<p>Let's go deeper into the previous code:</p>"},{"location":"how_to/#rule-sets-and-rule-groups","title":"Rule sets and rule groups","text":"<p>A rule set is composed of rule groups which are themselves composed of rules. We can find this tree structure in the following dictionary:</p> <pre><code>rules = {  # (1)\n    \"check_admission\": {  # (2)\n        \"ADMITTED_RULE\": {  # (3)\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"},\n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None,\n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n</code></pre> <ol> <li>This dictionary contains a rule set.</li> <li>This key define a rule group, we can have many groups (we have only one here for simplicity).</li> <li>This key is a rule id, which identifies rules among others.</li> </ol>"},{"location":"how_to/#rules","title":"Rules","text":"<p>Rules are identified by an id or key (e.g., <code>ADMITTED_RULE</code>) and defined by a dictionary:</p> <pre><code>\"ADMITTED_RULE\": {\n    \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n    \"condition_parameters\": {\"power\": \"input.super_power\"}, \n    \"action\": set_admission,\n    \"action_parameters\": {\"value\": True},\n}\n</code></pre> <p>Tip</p> <p>Rule ids are in capital letters for readability only: it is an advised best practice.</p> <p>Rules are made of 2 different things:</p> <ul> <li>Condition:</li> </ul> <pre><code>{\n    \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n    \"condition_parameters\": {\"power\": \"input.super_power\"}, \n    \"action\": set_admission,\n    \"action_parameters\": {\"value\": True},\n}\n</code></pre> <ul> <li>Action: </li> </ul> <pre><code>{\n    \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n    \"condition_parameters\": {\"power\": \"input.super_power\"}, \n    \"action\": set_admission,\n    \"action_parameters\": {\"value\": True},\n}\n</code></pre>"},{"location":"how_to/#conditions-and-actions","title":"Conditions and Actions","text":"<p>Conditions and actions are quite similar in terms of implementation but their goal is different.</p> <p>Both are made of a callable object and parameters:</p> <ul> <li>Condition keys:<ul> <li><code>condition</code>: a callable python object that returns a <code>bool</code>, we called this function the validation function (or condition function).</li> <li><code>condition_parameters</code>: a dictionary mapping the validation function's parameters with their correponding values.</li> </ul> </li> <li>Action keys:<ul> <li><code>action</code>: a callable python object that returns what you want (or does what you want such as: requesting an api, sending an email, etc.), we called this function the action function.</li> <li><code>action_parameters</code>: a dictionary mapping the action function's parameters with their correponding values.</li> </ul> </li> </ul> <p>Does a condition could be something else than a function?</p> <p>Actually yes, a <code>condition</code> can be a python function but you will learn later that it can also be a condition expression (i.e., a boolean expression combining different individual conditions).</p> <p>Parameter's special syntax</p> <p>As you can see in the previous code, the action and condition parameters can have a special syntax: </p> <pre><code>{\"power\": \"input.super_power\"}\n</code></pre> <p>The string <code>input.super_power</code> is evaluated by the rules engine and it means \"fetch the key <code>super_power</code> in the input data\". Keep reading, you will find out later.</p>"},{"location":"how_to/#configuration","title":"Configuration","text":"<p>In the Hello World section of this user guide, you learnt how to instanciate and use the rules engine with a dictionary rule set. It's the reason why you used the correponding parameter <code>rules_dict</code> for the instancation:</p> <pre><code>eng = RulesEngine(rules_dict=rules)\n</code></pre> <p>But there is another way to define your rules: using a configuration (i.e., some configuration files). </p> <p>For real use cases, using configuration is way much more convenient than using a dictionary </p> <p>YAML</p> <p>The built-in file format used by Arta for configuration is YAML.</p> <p>Enhancement proposal</p> <p>We are thinking on a design that will allow custom configuration backend which will allow user-implemented loading of the configuration (e.g., you prefer using a JSON format). Stay tuned.</p>"},{"location":"how_to/#yaml-file","title":"YAML file","text":"<p>Simple Conditions</p> <p>The following YAML example illustrates how to configure usual standard conditions but there is another and simpler way to do it by using a special feature: the simple condition.</p> <p>Create a YAML file and define your rules almost like you did with the dictionary <code>rules</code>. There is few differences that we will focus on later:</p> <pre><code>---\nrules:\n  default_rule_set:  # (1)\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER  # (2)\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:  # (3)\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:  # (4)\n  - my_folder.conditions\nactions_source_modules:  # (5)\n  - my_folder.actions\n</code></pre> <ol> <li>This is the name of your rule set (i.e., <code>default_rule_set</code> is by default).</li> <li>You can't set a callable object here so we need to use a condition id.</li> <li>The conditions are identified by an id and defined here. The validation function is defined in a user's python module.</li> <li>This is the path of the module where the validation functions are implemented (you must change it).</li> <li>This is the path of the module where the action functions are implemented (you must change it).</li> </ol> <p>Warning</p> <p>Condition ids must be in capital letters here, it is mandatory (e.g., <code>HAS_SCHOOL_AUTHORIZED_POWER</code>).</p> <p>Tip</p> <p>You can split your configuration in multiple YAML files seamlessly in order to keep things clear. Example:</p> <ul> <li>global.yaml =&gt; source modules</li> <li>rules.yaml =&gt; rule definitions</li> <li>conditions.yaml =&gt; condition definitions</li> </ul> <p>It's very convenient when you have a lot of different rules and conditions in your app.</p>"},{"location":"how_to/#condition-expression","title":"Condition expression","text":"<p>In the above YAML, the following condition expression is intentionally very simple:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <p>As it was previously mentionned, the key <code>condition:</code> can take one condition id but also a condition expression (i.e., a boolean expression of condition ids) combining several conditions:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: (HAS_SCHOOL_AUTHORIZED_POWER or SPEAKS_FRENCH) and not(IS_EVIL)\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <p>Warning</p> <p>In that example, you must define the 3 condition ids in the configuration:</p> <ul> <li>HAS_SCHOOL_AUTHORIZED_POWER</li> <li>SPEAKS_FRENCH</li> <li>IS_EVIL</li> </ul> <p>Tip</p> <p>Use the condition expressions to keep things simple. Put your conditions in one expression as you can rather than creating several rules </p>"},{"location":"how_to/#implementing-functions","title":"Implementing functions","text":"<p>We must create 2 modules:</p> <ul> <li><code>conditions.py</code> -&gt; implements the needed validation functions.</li> <li><code>actions.py</code> -&gt; implements the needed action functions.</li> </ul> <p>Note</p> <p>Module names are arbitrary, you can choose what you want.</p> <p>And implement our 2 needed validation and action functions (the one defined in the configuration file): </p> <p>conditions.py:</p> <pre><code>def has_authorized_super_power(power):\n    return power in [\"strength\", \"fly\", \"immortality\"]\n</code></pre> <p>actions.py:</p> <pre><code>def set_admission(value, **kwargs):  # (1)\n    return {\"is_admitted\": value}\n</code></pre> <ol> <li><code>**kwargs</code> is mandatory here.</li> </ol> <p>Warning</p> <p>Function name and parameters must be the same as the one configured in the YAML file.</p>"},{"location":"how_to/#usage","title":"Usage","text":"<p>Once your configuration file and your functions are ready, you can use it very simply:</p> <pre><code>from arta import RulesEngine\n\ninput_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(config_path=\"path/to/conf/dir\")\n\nresult = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <p>You should get the same result as previously (dictionary version):</p> <pre><code>{'check_admission': {'is_admitted': True}}\n</code></pre>"},{"location":"how_to/#to-sum-up","title":"To sum up","text":"<p>At this point you have learnt the regular use of an Arta rules engine and you have seen the two major ways of defining rules: </p> <ul> <li>Using a dictionary of rules.</li> <li>Using a configuration file (or many).</li> </ul> <p>Tip</p> <p>How to choose between dictionary and configuration?</p> <p>In most cases, you must choose the configuration way of defining your rules. You will improve your rules' maintainability a lot. In some cases like proof-of-concepts or Jupyter notebook works, you will probably be happy to use straightforward dictionaries.</p> <p>Arta has plenty more features to discover. If you want to learn more, go to the next chapter: Advanced User Guide.</p>"},{"location":"in_a_nutshell/","title":"In a nutshell","text":""},{"location":"in_a_nutshell/#intro","title":"Intro","text":"<p>As we already mentioned in the Home page: Arta is a very simple python rules engine, but what do we mean by rules engine?</p> <ul> <li>rule : a set of different conditions that can be <code>True</code> or <code>False</code> (i.e., we say verified or not verified) triggering an action (i.e., any python callable object).</li> <li>engine : some code used for combining and evaluating different rules on some input data.</li> </ul>"},{"location":"in_a_nutshell/#quick-example-the-superhero-school","title":"Quick example: The Superhero School","text":"<p>Imagine the following use case: </p> <p>Your are managing a superhero school and you want to use some school rules in your python app.</p> <p>The rules are (intentionally simple):</p> <p>Admission rules</p> <p>If the applicant has a school authorized power then he is admitted, </p> <p>Else he is not.</p> <p>Course selection rules</p> <p>If he is speaking french and his age is known then he must take the \"french\" course, </p> <p>Else if his age is unknown (e.g., it's a very old superhero), then he must take the \"senior\" course,</p> <p>Else if he is not speaking french, then he must take the \"international\" course. </p> <p>Send favorite meal rules</p> <p>If he is admitted and has a prefered dish, then we send an email to the school cook with the dish name.</p>"},{"location":"in_a_nutshell/#focus-on-a-rule","title":"Focus on a rule","text":"<p>If we focus on one rule:</p> <p>If the applicant has a school authorized power then he is admitted, else he is not.</p> <p>Here we can identify:</p> <ul> <li>The condition: has a school authorized power (only one condition)</li> <li>The triggered action: is admitted</li> </ul>"},{"location":"in_a_nutshell/#focus-on-a-condition","title":"Focus on a condition","text":"<p>Let's be more precise on the following condition:</p> <p>has a school authorized power</p> <p>If we define a list of \"school authorized powers\" it will be easy to verify this condition for an applicant:</p> <pre><code>authorized_powers = [\n    \"strength\",\n    \"fly\",\n    \"immortality\",\n]\n</code></pre>"},{"location":"in_a_nutshell/#focus-on-an-action","title":"Focus on an action","text":"<p>Defining the action is probably the hardest part because it means defining the rules engine output, which depends on the use of the rules' results. </p> <p>Let's focus on the following action:</p> <p>he is admitted</p> <p>Let's say that in our use case, a simple dictionary key is used for storing the admission status: <code>{\"is_admitted\": True}</code></p> <p>We previously mentioned that action are python callable object, so it could be a simple function as:</p> <pre><code>def set_admission(value: bool, **kwargs: Any) -&gt; dict[str, bool]:\n    \"\"\"Return a dictionary containing the admission result.\"\"\"\n    return {\"is_admitted\": value}\n</code></pre> <p>We will see later how the <code>value</code> argument is passed to this action function.</p>"},{"location":"in_a_nutshell/#focus-on-the-input-data","title":"Focus on the input data","text":"<p>The rules engine is responsible for evaluating the configured rules against some data (usually named input data). </p> <p>In our use case, the input data could be a list of applicants:</p> <pre><code>applicants = [\n    {\n        \"id\": 1,\n        \"name\": \"Superman\",\n        \"civilian_name\": \"Clark Kent\",\n        \"age\": None,\n        \"city\": \"Metropolis\",\n        \"language\": \"french\",\n        \"powers\": [\"strength\", \"fly\"],\n        \"favorite_meal\": \"Spinach\",\n        \"secret_weakness\": \"Kryptonite\",\n        \"weapons\": [],\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Batman\",\n        \"civilian_name\": \"Bruce Wayne\",\n        \"age\": 33,\n        \"city\": \"Gotham City\",\n        \"language\": \"english\",\n        \"powers\": [\"bank_account\", \"determination\", \"strength\"],\n        \"favorite_meal\": None,\n        \"secret_weakness\": \"Feel alone\",\n        \"weapons\": [\"Hands\", \"Batarang\", \"Batgrenade\"],\n    },\n    {\n        \"id\": 3,\n        \"name\": \"Wonder Woman\",\n        \"civilian_name\": \"Diana Prince\",\n        \"age\": 5000,\n        \"city\": \"Island of Themyscira\",\n        \"language\": \"french\",\n        \"powers\": [\"strength\", \"greek_gods\", \"regeneration\", \"immortality\"],\n        \"favorite_meal\": None,\n        \"secret_weakness\": \"Lost faith in humanity\",\n        \"weapons\": [\"Magic lasso\", \"Bulletproof bracelets\", \"Sword\", \"Shield\"],\n    },\n]\n</code></pre>"},{"location":"in_a_nutshell/#focus-on-the-results","title":"Focus on the results","text":"<p>We talked about rules, conditions, actions and then input data, it is the rules engine responsability to put all them together and output some results.</p> <p>To do that we need only two things:</p> <ol> <li>Instanciating a rules engine (by giving it the rules' definition).</li> <li>Applying the rules on the input data.</li> </ol> <p>The first task is explained in the User Guide section as the second but if you are curious you will find a simple example below of how to apply the rules on a data set.</p> <p>Let's apply the rules on a single applicant of our data set:</p> <pre><code>from arta import RulesEngine\n\neng = RulesEngine(config_path=\"/to/my/config/dir\")  # (1)\n\nresult = eng.apply_rules(applicants[0])\n\nprint(result)  # (2)\n# {\n# \"admission\": {\"is_admitted\": True},\n# \"course_selection\": {\"course\": \"senior\"},\n# \"send_dish\": True\n# }\n</code></pre> <ol> <li>Many possibilites for instanciation, we will explain them later</li> <li>Print a single result for the first applicant</li> </ol> <p>In the rules engine result, we have 3 outputs: </p> <ul> <li><code>\"admission\": {\"is_admitted\": True},</code></li> <li><code>\"course_selection\": {\"course\": \"senior\"},</code></li> <li><code>\"send_dish\": True</code> </li> </ul> <p>It's simple, each correpond to one rule.</p> <p>Then we can apply the rules to all the data set (only 3 applicants):</p> <pre><code>from arta import RulesEngine\n\nresults = {applicant[\"name\"]: eng.apply_rules(applicant) for applicant in applicants}\n\nprint(results)  # (1)\n# {\n#   \"Superman\": {\n#       \"admission\": {\"is_admitted\": True}, \n#       \"course_selection\": {\"course\": \"senior\"}, \n#       \"send_dish\": True},\n#   \"Batman\": {\n#       \"admission\": {\"is_admitted\": True},\n#       \"course_selection\": {\"course\": \"international\"},\n#       \"send_dish\": False,\n#       },\n#   \"Wonder Woman\": {\n#       \"admission\": {\"is_admitted\": True},\n#       \"course_selection\": {\"course\": \"french\"},\n#       \"send_dish\": False,\n#       }\n# }\n</code></pre> <ol> <li>Print the results of all applicants</li> </ol> <p>Human readable format of the result</p> <p>Superman, Batman and Wonder Womam are all admitted to school. Superman to the \"senior\" course, Batman to the \"international\" course and Wonder Woman to the \"french\" one. An email has been sent to the cook with Superman's favorite meal 'spinach'.</p> <p>Now, if you want to learn how to configure your rules, go to the User Guide section.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python","title":"Python","text":"<p>Compatible with:</p> <p></p>"},{"location":"installation/#pip","title":"pip","text":"<p>In your python environment:</p>"},{"location":"installation/#regular-use","title":"Regular use","text":"<pre><code>pip install arta\n</code></pre>"},{"location":"installation/#development","title":"Development","text":"<pre><code>pip install arta[all]\n</code></pre>"},{"location":"parameters/","title":"Parameters","text":""},{"location":"parameters/#parsing-prefix-keywords","title":"Parsing prefix keywords","text":"<p>There is 2 allowed parsing prefix keywords:</p> <ul> <li><code>input</code>: corresponding to the <code>input_data</code>.</li> <li><code>output</code> : corresponding to the result output data (returned by the <code>apply_rules()</code> method).</li> </ul> <p>Here are examples:</p> <ol> <li><code>input.name</code>: maps to <code>input_data[\"name\"]</code>.</li> <li><code>output.check_admission.is_admitted</code>: maps to <code>result[\"check_admission\"][\"is_admitted\"]</code>.</li> </ol> <p>They both can be used in condition and action parameters.</p> <p>Info</p> <p>A value without any prefix keyword is a constant.</p>"},{"location":"parameters/#parsing-error","title":"Parsing error","text":""},{"location":"parameters/#raise-by-default","title":"Raise by default","text":"<p>By default, errors during condition and action parameters parsing are raised.</p> <p>If we refer to the Hello World example:</p> <pre><code>rules = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n</code></pre> <p>With modified data like:</p> <pre><code>input_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n</code></pre> <p>By default we will get a <code>KeyError</code> exception during the execution of the <code>apply_rules()</code> method because of <code>power</code> vs <code>super_power</code>.</p>"},{"location":"parameters/#ignore","title":"Ignore","text":"<p>You can change the by default raising behavior of the parameter's parsing.</p> <p>Two ways are possible:</p> <ul> <li>At the configuration level: impacts all the parameters.</li> <li>At the parameter's level. </li> </ul>"},{"location":"parameters/#configuration-level","title":"Configuration level","text":"<p>You just have to add the following key somewhere in your configuration:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n\nparsing_error_strategy: ignore  # (1)\n</code></pre> <ol> <li><code>parsing_error_strategy</code> has two possible values: <code>raise</code> and <code>ignore</code>.</li> </ol> <p>It will affect all the parameters.</p>"},{"location":"parameters/#parameter-level","title":"Parameter level","text":"<p>Quick Sum Up</p> <ul> <li><code>input.super_power?</code>: set the value to <code>None</code></li> <li><code>input.super_power?no_power</code>: set the value to <code>no_power</code></li> <li><code>input.super_power!</code>: force raise exception (case when ignore is set by default)</li> </ul> <p>You can also handle more precisely that aspect at parameter's level:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power?  # (1)\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n</code></pre> <ol> <li>Have you noticed the '?' ? If there is a <code>KeyError</code> when reading, <code>power</code> will be set to <code>None</code> rather than raising the exception.</li> </ol> <p>Info</p> <p>You can enforce raising exceptions at parameter's level with <code>!</code>.</p> <pre><code>power: input.super_power!\n</code></pre>"},{"location":"parameters/#default-value-parameter-level","title":"Default value (parameter level)","text":"<p>Finally, you can set a default value at parameter's level. This value will be used if there is an exception during parsing:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power?no_power  # (1)\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n</code></pre> <ol> <li>If there is an exception during parsing, <code>power</code> will be set to <code>\"no_power\"</code>.</li> </ol> <p>Good to know</p> <p>Parameter's level is overriding configuration level.</p>"},{"location":"rule_sets/","title":"Rule sets","text":"<p>Rule sets are a convenient way to separate your business rules into different collections. </p> <p>Doing so increases the rules' maintainability because of a better organization and fully uncoupled rules.</p> <p>Tip</p> <p>Rule sets are very usefull when you have a lot of rules.</p> <p>Info</p> <p>Most of the time, you won't need to handle different rule sets and will only use the default one: <code>default_rule_set</code>.</p> <p>The good news is that different rule sets can be used seamlessly with the same rules engine instance </p> <p>Let's take the following example:</p> <p>Based on the Hello World example, imagine that you need to add some rules about something totally different than the superhero school. Let's say rules for a dinosaur school.</p>"},{"location":"rule_sets/#configuration","title":"Configuration","text":"<p>Update your configuration by adding a new rule set: <code>dinosaur_school_set</code></p> <pre><code>---\nrules:\n  superhero_school_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n  dinosaur_school_set:  # (1)\n    food_habit:\n      HERBIVOROUS:\n        condition: not(IS_EATING_MEAT)\n        action: send_mail_to_cook\n        action_parameters:\n          meal: \"plant\"\n      CARNIVOROUS:\n        condition: null\n        action: send_mail_to_cook\n        action_parameters:\n          meal: \"meat\"\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n  IS_EATING_MEAT:  # (2)\n    description: \"Is dinosaur eating meat?\"\n    validation_function: is_eating_meat\n    condition_parameters:\n      power: input.diet.regular_food\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules:\n  - my_folder.actions\n</code></pre> <ol> <li>Add your new set of rules under the <code>rules</code> key</li> <li>Regular condition configuration, nothing new here</li> </ol> <p>Good to know</p> <p>You can define your rule sets into different YAML files (under the <code>rules</code> key in each).</p>"},{"location":"rule_sets/#usage","title":"Usage","text":"<p>Now that your rule sets are defined (and assuming that your condition and action functions are implemented in the right modules), you can easily use them:</p> <pre><code>from arta import RulesEngine\n\ninput_data_1 = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\ninput_data_2 = {\n    \"id\": 1,\n    \"name\": \"Diplodocus\",\n    \"age\": 152000000,\n    \"length\": 31,\n    \"area\": \"north_america\",\n    \"diet\": {\n        \"regular_food\": \"plants\",\n    },\n}\n\neng = RulesEngine(config_path=\"path/to/conf/dir\")\n\nsuperhero_result = eng.apply_rules(input_data_1, rule_set=\"superhero_school_set\")  # (1)\n\ndinosaur_result = eng.apply_rules(input_data_2, rule_set=\"dinosaur_school_set\")\n</code></pre> <ol> <li>Select the rule set that you want to use when applying rules on your input data.</li> </ol> <p>Good to know</p> <p>Input data can be different or the same among the rule sets. It depends on the use case.</p>"},{"location":"rule_sets/#object-oriented-model","title":"Object-Oriented Model","text":"<pre><code>classDiagram\n    rule_set \"1\" -- \"1..*\" rule_group\n    rule_group \"1\" -- \"1..*\" rule\n    rule \"1..*\" -- \"0..*\" condition\n    rule \"1..*\" -- \"1\" action</code></pre>"},{"location":"special_conditions/","title":"Special conditions","text":""},{"location":"special_conditions/#simple-condition","title":"Simple condition","text":"<p>Beta feature</p> <p>Simple condition is still a beta feature, some cases could not work as designed.</p> <p>Simple conditions are a new and straightforward way of configuring your conditions.</p> <p>It simplifies a lot your rules by:</p> <ul> <li>Removing the use of a <code>conditions.py</code> module (no validation functions needed).</li> <li>Removing the <code>conditions:</code> configuration key in your YAML files.</li> </ul> <p>Note</p> <p>With the simple conditions you use straight boolean expressions directly in your configuration.</p> <p>It is easyer to read and maintain </p> <p>Example :</p> <pre><code>---\nrules:\n  default_rule_set:\n    admission:\n      ADM_OK:\n        simple_condition: input.power==\"strength\" or input.power==\"fly\"\n        action: set_admission\n        action_parameters:\n          value: OK \n      ADM_TO_BE_CHECKED:\n        simple_condition: input.age&gt;=150 and input.age!=None\n        action: set_admission\n        action_parameters:\n          value: TO_CHECK     \n      ADM_KO:\n        simple_condition: null\n        action: set_admission\n        action_parameters:\n          value: KO\n\nactions_source_modules:\n  - my_folder.actions  # (1)\n</code></pre> <ol> <li>Contains action function implementations, no need of the key <code>conditions_source_modules</code> here.</li> </ol> <p>How to write a simple condition like:</p> <pre><code>input.power==\"strength\" or input.power==\"fly\"\n</code></pre> <ul> <li>Left operand (data mapping): <ul> <li>You must use one of the following prefixes: <ul> <li><code>input</code> (for input data)</li> <li><code>output</code> (for previous rule's result)</li> </ul> </li> <li>A dot path expression like <code>input.powers.main_power</code>.</li> </ul> </li> <li>Operator: you must use basic python boolean operator (i.e., <code>==, &lt;, &gt;, &lt;=, &gt;=, !=</code>)</li> <li>Right operand: basic python data types (e.i., <code>str, int, None</code>).</li> </ul> <p>Warning</p> <ul> <li>You can't use: <code>is</code> or <code>in</code>, as an operator (yet).</li> <li>You can't use a <code>float</code> as right operand (it's a bug, will be fixed).</li> <li>For strings, don't forget the double quotes <code>\"</code>.</li> </ul> <p>Security concern</p> <p>Python code injection:</p> <p>Because Arta is using the <code>eval()</code> built-in function to evaluate simple conditions:</p> <ul> <li>You should never let the user being able of dynamically define a simple condition (in <code>simple_condition:</code> conf. key).</li> <li>You should verify that write permissions on the YAML files are not allowed when your app is deployed.</li> </ul>"},{"location":"special_conditions/#custom-condition","title":"Custom condition","text":"<p>Custom conditions are user-defined conditions. </p> <p>A custom condition will impact the atomic evaluation of each conditions (i.e., condition ids).</p> <p>Vocabulary</p> <p>To be more precise, a condition expression is something like:</p> <pre><code>CONDITION_1 and CONDITION_2\n</code></pre> <p>In that example, the condition expression is made of 2 conditions whose condition ids are:</p> <ul> <li>CONDITION_1</li> <li>CONDITION_2</li> </ul> <p>With the built-in condition (also named standard condition), condition ids map to validation functions and condition parameters but we can change that with a brand new custom condition.</p> <p>A custom condition example:</p> <pre><code>my_condition: NAME_JOHN and AGE_42\n</code></pre> <p>Remember</p> <p>condition ids have to be in CAPITAL LETTERS.</p> <p>Imagine you want it to be interpreted as (pseudo-code):</p> <pre><code>if input.name == \"john\" and input.age == \"42\":\n    # Do something\n    ...\n</code></pre> <p>With the custom conditions it's quite simple to implement.</p> <p>Why using a custom condition?</p> <p>The main goal is to simplify handling of recurrent conditions (e.i., \"recurrent\" meaning very similar conditions).</p>"},{"location":"special_conditions/#class-implementation","title":"Class implementation","text":"<p>First, create a class inheriting from <code>BaseCondtion</code> and implement the <code>verify()</code> method as you want/need:</p> Python &gt;= 3.10Python &lt; 3.10 <pre><code>from typing import Any\n\nfrom arta.condition import BaseCondition\nfrom arta.utils import ParsingErrorStrategy\n\n\nclass MyCondition(BaseCondition):\n    def verify(\n        self,\n        input_data: dict[str, Any],\n        parsing_error_strategy: ParsingErrorStrategy,\n    ) -&gt; bool:\n\n        field, value = tuple(self.condition_id.split(\"_\"))\n\n        return input_data[field.lower()] == value.lower()\n</code></pre> <pre><code>from typing import Any, Optional\n\nfrom arta.condition import BaseCondition\nfrom arta.utils import ParsingErrorStrategy\n\n\nclass MyCondition(BaseCondition):\n    def verify(\n        self,\n        input_data: dict[str, Any],\n        parsing_error_strategy: ParsingErrorStrategy,\n    ) -&gt; bool:\n\n        field, value = tuple(self.condition_id.split(\"_\"))\n\n        return input_data[field.lower()] == value.lower()\n</code></pre> <p>self.condition_id</p> <p><code>self.condition_id</code> will be <code>NAME_JOHN</code> for the first condition and <code>AGE_42</code> for the second.</p> <p>Good to know</p> <p>The <code>parsing_error_strategy</code> can be used by the developer to adapt exception handling behavior. Possible values:</p> <pre><code>ParsingErrorStrategy.RAISE\nParsingErrorStrategy.IGNORE\nParsingErrorStrategy.DEFAULT_VALUE\n</code></pre>"},{"location":"special_conditions/#configuration","title":"Configuration","text":"<p>Last thing to do is to add your new custom condition in the configuration:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        my_condition: NAME_JOHN and AGE_42  # (1)\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n\ncustom_classes_source_modules:\n  - dir.to.my_module  # (2)\ncondition_factory_mapping:\n  my_condition: MyCondition # (3)\n</code></pre> <ol> <li>Order is important, here it will evaluate <code>condition</code> then <code>my_condition</code>. Order is arbitrary.</li> <li>List of the modules containing custom classes</li> <li>Mapping between condition keys (<code>my_condition</code>) and custom classes (<code>MyCondition</code>)</li> </ol>"},{"location":"special_conditions/#class-diagram","title":"Class diagram","text":"<p>It is based on the following strategy pattern:</p> <pre><code>classDiagram\n    note for MyCondition \"This is a custom condition class\"\n    RulesEngine \"1\" -- \"1..*\" Rule\n    Rule \"0..*\" -- \"0..*\" BaseCondition\n    BaseCondition &lt;|-- StandardCondition\n    BaseCondition &lt;|-- MyCondition\n    class RulesEngine{\n        +rules\n        +apply_rules()\n    }\n    class Rule {\n        #set_id\n        #group_id\n        #rule_id\n        #condition_exprs\n        #action\n        #action_parameters\n        +apply()\n    }\n    class BaseCondition {\n        &lt;&lt;abstract&gt;&gt;\n        #condition_id\n        #description\n        #validation_function\n        #validation_function_parameters\n        +verify()\n    }</code></pre> <p>Good to know</p> <p>The class <code>StandardCondition</code> is the built-in implementation of a condition.</p>"},{"location":"why/","title":"Why use Arta?","text":"<p>There is one main reason for using Arta and it was the main goal of its development: </p> <p>Increase business rules maintainability.</p> <p>In other words, facilitate rules handling in a python app.</p>"},{"location":"why/#before-arta","title":"Before Arta","text":"<p>Rules in code can rapidly become a headache, kind of spaghetti dish of <code>if</code>, <code>elif</code> and <code>else</code> (or even <code>match/case</code> since Python 3.10) </p>"},{"location":"why/#after-arta","title":"After Arta","text":"<p>Arta increases rules maintainability:</p> <ul> <li>By standardizing the definition of a rule. All rules are configured or defined the same way in a unique place (or few).</li> <li>Rules are released from the code base, which is less error prone and increases clearness.</li> </ul> <p>Improve collaboration</p> <p>Reading python code vs reading YAML.</p>"}]}
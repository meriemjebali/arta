{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"a_simple_example/","title":"A Simple Example","text":""},{"location":"a_simple_example/#intro","title":"Intro","text":"<p>As we already mentioned: Arta is a simple python rules engine.</p> <p>But what do we mean by rules engine?</p> <ul> <li>rule : a set of different conditions that can be <code>True</code> or <code>False</code> (i.e., we say verified or not verified) triggering an action (i.e., any python callable object).</li> <li>engine : some code used for combining and evaluating different rules on some input data.</li> </ul>"},{"location":"a_simple_example/#the-superhero-school","title":"The Superhero School","text":"<p>Imagine the following use case: </p> <p>Your are managing a superhero school and you want to use some school rules in your python app.</p> <p>The rules (intentionally simple) are:</p> <p>Admission rules</p> <p>If the applicant has a school authorized power then he is admitted, </p> <p>Else he is not.</p> <p>Course selection rules</p> <p>If he is speaking french and his age is known then he must take the \"french\" course, </p> <p>Else if his age is unknown (e.g., it's a very old superhero), then he must take the \"senior\" course,</p> <p>Else if he is not speaking french, then he must take the \"international\" course. </p> <p>Send favorite meal rules</p> <p>If he is admitted and has a prefered dish, then we send an email to the school cook with the dish name.</p>"},{"location":"a_simple_example/#rules","title":"Rules","text":"<p>You can define above rules for Arta in one simple YAML file :</p> <pre><code>---\nrules:\n  default_rule_set:\n    admission:\n      ADMITTED:\n        simple_condition: input.power==\"strength\" or input.power==\"fly\"\n        action: set_admission\n        action_parameters:\n          value: True  \n      NOT_ADMITTED:\n        simple_condition: null\n        action: set_admission\n        action_parameters:\n          value: False\n    course:\n      FRENCH:\n        simple_condition: input.language==\"french\" and input.age!=None\n        action: set_course\n        action_parameters:\n          value: french\n      SENIOR:\n        simple_condition: input.age==None\n        action: set_course\n        action_parameters:\n          value: senior\n      INTERNATIONAL:\n        simple_condition: input.language!=\"french\"\n        action: set_course\n        action_parameters:\n          value: international\n    favorite_meal:\n      EMAIL:\n        simple_condition: input.favorite_meal!=None\n        action: send_email\n        action_parameters:\n          mail_to: cook@super-heroes.test\n          mail_content: \"Thanks for preparing once a month the following dish:\"\n          meal: input.favorite_meal\n\nactions_source_modules:\n  - my_folder.actions\n</code></pre> <p>Simple Conditions</p> <p>This configuration uses what we called simple conditions, you can find out more here.</p>"},{"location":"a_simple_example/#actions","title":"Actions","text":"<p>An action is triggered when the conditions are verified (i.e., <code>True</code>).</p> <p>Actions are defined by the following keys in the previous YAML file:</p> <pre><code>        action: set_admission  # (1)\n        action_parameters:  # (2)\n          value: True  \n</code></pre> <ol> <li>Name of the python callable object used as an action function.</li> <li>The action function arguments.</li> </ol> <p>The action function's implementation has to be located in the configured module:</p> <pre><code>actions_source_modules:\n  - my_folder.actions\n</code></pre> <p>And could be for example (intentionally simple) in <code>actions.py</code>:</p> <pre><code>def set_admission(value: bool, **kwargs: Any) -&gt; dict[str, bool]:\n    \"\"\"Return a dictionary containing the admission result.\"\"\"\n    return {\"is_admitted\": value}\n\n\ndef set_course(course_id: str, **kwargs: Any) -&gt; dict[str, str]:\n    \"\"\"Return the course id as a dictionary.\"\"\"\n    return {\"course_id\": course_id}\n\n\ndef send_email(mail_to: str, mail_content: str, meal: str, **kwargs: Any) -&gt; bool:\n    \"\"\"Send an email.\"\"\"\n    result: str | None = None\n\n    if meal is not None:\n        # API call here\n        result = \"sent\"\n\n    return result\n</code></pre> <p>**kwargs</p> <p>**kwargs is mandatory in action functions.</p>"},{"location":"a_simple_example/#engine","title":"Engine","text":"<p>The rules engine is responsible for evaluating the configured rules against some data (usually named \"input data\"). </p> <p>In our use case, the input data could be a list of applicants:</p> <pre><code>applicants = [\n    {\n        \"id\": 1,\n        \"name\": \"Superman\",\n        \"civilian_name\": \"Clark Kent\",\n        \"age\": None,\n        \"city\": \"Metropolis\",\n        \"language\": \"english\",\n        \"power\": \"fly\",\n        \"favorite_meal\": \"Spinach\",\n        \"secret_weakness\": \"Kryptonite\",\n        \"weapons\": [],\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Batman\",\n        \"civilian_name\": \"Bruce Wayne\",\n        \"age\": 33,\n        \"city\": \"Gotham City\",\n        \"language\": \"english\",\n        \"power\": \"strength\",\n        \"favorite_meal\": None,\n        \"secret_weakness\": \"Feel alone\",\n        \"weapons\": [\"Hands\", \"Batarang\"],\n    },\n    {\n        \"id\": 3,\n        \"name\": \"Wonder Woman\",\n        \"civilian_name\": \"Diana Prince\",\n        \"age\": 5000,\n        \"city\": \"Island of Themyscira\",\n        \"language\": \"french\",\n        \"power\": \"strength\",\n        \"favorite_meal\": None,\n        \"secret_weakness\": \"Lost faith in humanity\",\n        \"weapons\": [\"Magic lasso\", \"Bulletproof bracelets\", \"Sword\", \"Shield\"],\n    },\n]\n</code></pre> <p>Now, let's apply the rules on a single applicant:</p> <pre><code>from arta import RulesEngine\n\neng = RulesEngine(config_path=\"/to/my/config/dir\")  # (1)\n\nresult = eng.apply_rules(input_data=applicants[0])\n\nprint(result)  # (2)\n# {\n# \"admission\": {\"is_admitted\": True},\n# \"course\": {\"course_id\": \"senior\"},\n# \"favorite_meal\": \"sent\"\n# }\n</code></pre> <ol> <li>Many possibilites for instanciation, we will explain them later.</li> <li>Print a single result for the first applicant.</li> </ol> <p>In the rules engine result, we have 3 outputs: </p> <ul> <li><code>\"admission\": {\"is_admitted\": True},</code></li> <li><code>\"course\": {\"course_id\": \"senior\"},</code></li> <li><code>\"favorite_meal\": \"sent\"</code> </li> </ul> <p>Each corresponds to one of these rules.</p> <p>Here, we can apply the rules to all the data set (3 applicants) with a simple dictionary comprehension:</p> <pre><code>from arta import RulesEngine\n\nresults = {applicant[\"name\"]: eng.apply_rules(applicant) for applicant in applicants}\n\nprint(results)\n# {\n#   \"Superman\": {\n#       \"admission\": {\"is_admitted\": True}, \n#       \"course\": {\"course_id\": \"senior\"}, \n#       \"favorite_meal\": \"sent\"},\n#   \"Batman\": {\n#       \"admission\": {\"is_admitted\": True},\n#       \"course\": {\"course_id\": \"international\"},\n#       \"favorite_meal\": None,\n#       },\n#   \"Wonder Woman\": {\n#       \"admission\": {\"is_admitted\": True},\n#       \"course\": {\"course_id\": \"french\"},\n#       \"favorite_meal\": None,\n#       }\n# }\n</code></pre> <p>It is the end of this Arta's overview. If you want now to go deeper in how to use Arta, click here.</p>"},{"location":"api_reference/","title":"API Reference","text":""},{"location":"api_reference/#_enginepy","title":"_engine.py","text":"<p>Module implementing the rules engine.</p> <p>Class: RulesEngine</p>"},{"location":"api_reference/#arta._engine.RulesEngine","title":"<code>RulesEngine</code>","text":"<p>The Rules Engine is in charge of executing different groups of rules of a given rule set on user input data.</p> <p>Attributes:</p> Name Type Description <code>rules</code> <code>dict[str, dict[str, list[Rule]]]</code> <p>A dictionary of rules with k: rule set, v: (k: rule group, v: list of rule instances).</p> Source code in <code>arta/_engine.py</code> <pre><code>class RulesEngine:\n    \"\"\"The Rules Engine is in charge of executing different groups of rules of a given rule set on user input data.\n\n    Attributes:\n        rules:  A dictionary of rules with k: rule set, v: (k: rule group, v: list of rule instances).\n    \"\"\"\n\n    # ==== Class constants ====\n\n    # Rule related config keys\n    CONST_RULE_SETS_CONF_KEY: str = \"rules\"\n    CONST_DFLT_RULE_SET_ID: str = \"default_rule_set\"\n    CONST_STD_RULE_CONDITION_CONF_KEY: str = \"condition\"\n    CONST_ACTION_CONF_KEY: str = \"action\"\n    CONST_ACTION_PARAMETERS_CONF_KEY: str = \"action_parameters\"\n\n    # Condition related config keys\n    CONST_STD_CONDITIONS_CONF_KEY: str = \"conditions\"\n    CONST_CONDITION_VALIDATION_FUNCTION_CONF_KEY: str = \"validation_function\"\n    CONST_CONDITION_DESCRIPTION_CONF_KEY: str = \"description\"\n    CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY: str = \"condition_parameters\"\n    CONST_USER_CONDITION_STRING: str = \"USER_CONDITION\"\n\n    # Built-in factory mapping\n    BUILTIN_FACTORY_MAPPING: dict[str, type[BaseCondition]] = {\n        \"condition\": StandardCondition,\n        \"simple_condition\": SimpleCondition,\n    }\n\n    def __init__(\n        self,\n        *,\n        rules_dict: dict[str, dict[str, Any]] | None = None,\n        config_path: str | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the rules.\n\n        2 possibilities: either 'rules_dict', or 'config_path', not both.\n\n        Args:\n            rules_dict: A dictionary containing the rules' definitions.\n            config_path: Path of a directory containing the YAML files.\n\n        Raises:\n            KeyError: Key not found.\n            TypeError: Wrong type.\n        \"\"\"\n        # Var init.\n        factory_mapping_classes: dict[str, type[BaseCondition]] = {}\n        std_condition_instances: dict[str, StandardCondition] = {}\n\n        if config_path is not None and rules_dict is not None:\n            raise ValueError(\"RulesEngine takes only one parameter: 'rules_dict' or 'config_path', not both.\")\n\n        # Init. default parsing_error_strategy (probably not needed because already defined elsewhere)\n        self._parsing_error_strategy: ParsingErrorStrategy = ParsingErrorStrategy.RAISE\n\n        # Initialize directly with a rules dict\n        if rules_dict is not None:\n            # Data validation\n            RulesDict.parse_obj(rules_dict)\n\n            # Edge cases data validation\n            if not isinstance(rules_dict, dict):\n                raise TypeError(f\"'rules_dict' must be dict type, not '{type(rules_dict)}'\")\n            elif len(rules_dict) == 0:\n                raise KeyError(\"'rules_dict' couldn't be empty.\")\n\n            # Attribute definition\n            self.rules: dict[str, dict[str, list[Rule]]] = self._adapt_user_rules_dict(rules_dict)\n\n        # Initialize with a config_path\n        elif config_path is not None:\n            # Load config in attribute\n            config_dict: dict[str, Any] = load_config(config_path)\n\n            # Data validation\n            config: Configuration = Configuration(**config_dict)\n\n            if config.parsing_error_strategy is not None:\n                # Set parsing error handling strategy from config\n                self._parsing_error_strategy = ParsingErrorStrategy(config.parsing_error_strategy)\n\n            # dict of available action functions (k: function name, v: function object)\n            action_modules: list[str] = config.actions_source_modules\n            action_functions: dict[str, Callable] = self._get_object_from_source_modules(action_modules)\n\n            # dict of available standard condition functions (k: function name, v: function object)\n            condition_modules: list[str] = (\n                config.conditions_source_modules if config.conditions_source_modules is not None else []\n            )\n            std_condition_functions: dict[str, Callable] = self._get_object_from_source_modules(condition_modules)\n\n            # Dictionary of condition instances (k: condition id, v: instance), built from config data\n            if len(std_condition_functions) &gt; 0:\n                std_condition_instances = self._build_std_conditions(\n                    config=config.dict(), condition_functions_dict=std_condition_functions\n                )\n\n            # User-defined/custom conditions\n            if config.condition_factory_mapping is not None and config.custom_classes_source_modules is not None:\n                # dict of custom condition classes (k: classe name, v: class object)\n                custom_condition_classes: dict[str, type[BaseCondition]] = self._get_object_from_source_modules(\n                    config.custom_classes_source_modules\n                )\n\n                # Build a factory mapping dictionary (k: conf key, v:class object)\n                factory_mapping_classes.update(\n                    {\n                        conf_key: custom_condition_classes[class_name]\n                        for conf_key, class_name in config.condition_factory_mapping.items()\n                    }\n                )\n\n            # Arta built-in conditions\n            factory_mapping_classes.update(self.BUILTIN_FACTORY_MAPPING)\n\n            # Attribute definition\n            self.rules = self._build_rules(\n                std_condition_instances=std_condition_instances,\n                action_functions=action_functions,\n                config=config.dict(),\n                factory_mapping_classes=factory_mapping_classes,\n            )\n        else:\n            raise ValueError(\"RulesEngine needs a parameter: 'rule_dict' or 'config_path'.\")\n\n    def apply_rules(\n        self, input_data: dict[str, Any], *, rule_set: str | None = None, verbose: bool = False, **kwargs: Any\n    ) -&gt; dict[str, Any]:\n        \"\"\"Apply the rules and return results.\n\n        For each rule group of a given rule set, rules are applied sequentially,\n        The loop is broken when a rule is applied (an action is triggered).\n        Then, the next rule group is evaluated.\n        And so on...\n\n        This means that the order of the rules in the configuration file\n        (e.g., rules.yaml) is meaningful.\n\n        Args:\n            input_data: Input data to apply rules on.\n            rule_set: Apply rules associated with the specified rule set.\n            verbose: If True, add extra ids (group_id, rule_id) for result explicability.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            A dictionary containing the rule groups' results (k: group id, v: action result).\n\n        Raises:\n            TypeError: Wrong type.\n            KeyError: Key not found.\n        \"\"\"\n        # Input_data validation\n        if not isinstance(input_data, dict):\n            raise TypeError(f\"'input_data' must be dict type, not '{type(input_data)}'\")\n        elif len(input_data) == 0:\n            raise KeyError(\"'input_data' couldn't be empty.\")\n\n        # Var init.\n        input_data_copy: dict[str, Any] = copy.deepcopy(input_data)\n\n        # Prepare the result key\n        input_data_copy[\"output\"] = {}\n\n        # If there is no given rule set param. and there is only one rule set in self.rules\n        # and its value is 'default_rule_set', look for this one (rule_set='default_rule_set')\n        if rule_set is None and len(self.rules) == 1 and self.rules.get(self.CONST_DFLT_RULE_SET_ID) is not None:\n            rule_set = self.CONST_DFLT_RULE_SET_ID\n\n        # Check if given rule set is in self.rules?\n        if rule_set not in self.rules:\n            raise KeyError(\n                f\"Rule set '{rule_set}' not found in the rules, available rule sets are : {list(self.rules.keys())}.\"\n            )\n\n        # Var init.\n        results_dict: dict[str, Any] = {\"verbosity\": {\"rule_set\": rule_set, \"results\": []}}\n\n        # Groups' loop\n        for group_id, rules_list in self.rules[rule_set].items():\n            # Initialize result of the rule group with None\n            results_dict[group_id] = None\n\n            # Rules' loop (inside a group)\n            for rule in rules_list:\n                # Apply rules\n                action_result, rule_details = rule.apply(\n                    input_data_copy, parsing_error_strategy=self._parsing_error_strategy, **kwargs\n                )\n\n                # Check if the rule has been applied (= action activated)\n                if \"action_result\" in rule_details:\n                    # Save result and details\n                    results_dict[group_id] = action_result\n                    results_dict[\"verbosity\"][\"results\"].append(rule_details)\n\n                    # Update input data with current result with key 'output' (can be used in next rules)\n                    input_data_copy[\"output\"][group_id] = copy.deepcopy(results_dict[group_id])\n\n                    # We can only have one result per group =&gt; break when \"action_result\" in rule_details\n                    break\n\n        # Handling non-verbose mode\n        if not verbose:\n            results_dict.pop(\"verbosity\")\n\n        return results_dict\n\n    @staticmethod\n    def _get_object_from_source_modules(module_list: list[str]) -&gt; dict[str, Any]:\n        \"\"\"(Protected)\n        Collect all functions defined in the list of modules.\n\n        Args:\n            module_list: List of source module names.\n\n        Returns:\n            Dictionary with objects found in the modules.\n        \"\"\"\n        object_dict: dict[str, Any] = {}\n\n        for module_name in module_list:\n            # Import module\n            mod: ModuleType = importlib.import_module(module_name)\n\n            # Collect functions\n            module_functions: dict[str, Any] = {key: val for key, val in getmembers(mod, isfunction)}\n            object_dict.update(module_functions)\n\n            # Collect classes\n            module_classes: dict[str, Any] = {key: val for key, val in getmembers(mod, isclass)}\n            object_dict.update(module_classes)\n\n        return object_dict\n\n    def _build_rules(\n        self,\n        std_condition_instances: dict[str, StandardCondition],\n        action_functions: dict[str, Callable],\n        config: dict[str, Any],\n        factory_mapping_classes: dict[str, type[BaseCondition]],\n    ) -&gt; dict[str, dict[str, list[Any]]]:\n        \"\"\"(Protected)\n        Return a dictionary of Rule instances built from the configuration.\n\n        Args:\n            rule_sets: Sets of rules to be loaded in the Rules Engine (as needed by further uses).\n            std_condition_instances: Dictionary of condition instances (k: condition id, v: StandardCondition instance)\n            actions_dict: Dictionary of action functions (k: action name, v: Callable)\n            config: Dictionary of the imported configuration from yaml files.\n            factory_mapping_classes: A mapping dictionary (k: condition conf. key, v: custom class object)\n\n        Returns:\n            A dictionary of rules.\n        \"\"\"\n        # Var init.\n        rules_dict: dict[str, dict[str, list[Any]]] = {}\n\n        # Retrieve rule set ids from config\n        rule_set_ids: list[str] = list(config[self.CONST_RULE_SETS_CONF_KEY].keys())\n\n        # Going all way down to the rules (rule set &gt; rule group &gt; rule)\n        for set_id in rule_set_ids:\n            rules_conf: dict[str, Any] = config[self.CONST_RULE_SETS_CONF_KEY][set_id]\n            rules_dict[set_id] = {}\n            rule_set_dict: dict[str, list[Any]] = rules_dict[set_id]\n\n            # Looping throught groups\n            for group_id, group_rules in rules_conf.items():\n                # Initialize list or rules in the group\n                rule_set_dict[group_id] = []\n\n                # Looping through rules (inside a group)\n                for rule_id, rule_dict in group_rules.items():\n                    # Get action function\n                    action_function_name: str = rule_dict[self.CONST_ACTION_CONF_KEY]\n\n                    if action_function_name not in action_functions:\n                        raise KeyError(f\"Unknwown action function : {action_function_name}\")\n\n                    action: Callable = action_functions[action_function_name]\n\n                    # Look for condition conf. keys inside the rule\n                    condition_conf_keys: set[str] = set(rule_dict.keys()) - {\n                        self.CONST_ACTION_CONF_KEY,\n                        self.CONST_ACTION_PARAMETERS_CONF_KEY,\n                    }\n\n                    # Store the cond. expressions with the same order as in the configuration file (very important)\n                    condition_exprs: dict[str, str | None] = {\n                        key: value for key, value in rule_dict.items() if key in condition_conf_keys\n                    }\n\n                    # Create the corresponding Rule instance\n                    rule: Rule = Rule(\n                        set_id=set_id,\n                        group_id=group_id,\n                        rule_id=rule_id,\n                        action=action,\n                        action_parameters=rule_dict[self.CONST_ACTION_PARAMETERS_CONF_KEY],\n                        condition_exprs=condition_exprs,\n                        std_condition_instances=std_condition_instances,\n                        condition_factory_mapping=factory_mapping_classes,\n                    )\n                    rule_set_dict[group_id].append(rule)\n\n        return rules_dict\n\n    def _build_std_conditions(\n        self, config: dict[str, Any], condition_functions_dict: dict[str, Callable]\n    ) -&gt; dict[str, StandardCondition]:\n        \"\"\"(Protected)\n        Return a dictionary of Condition instances built from the configuration file.\n\n        Args:\n            config: Dictionary of the imported configuration from yaml files.\n            condition_functions_dict: A dictionary where k:condition id, v:Callable (validation function).\n\n        Returns:\n            A dictionary of StandardCondition instances (k: condition id, v: StandardCondition instance).\n        \"\"\"\n        # Var init.\n        conditions_dict: dict[str, StandardCondition] = {}\n\n        # Condition configuration (under conditions' key)\n        conditions_conf: dict[str, dict[str, Any]] = config[self.CONST_STD_CONDITIONS_CONF_KEY]\n\n        # Looping through conditions (inside a group)\n        for condition_id, condition_params in conditions_conf.items():\n            # Get condition validation function\n            validation_function_name: str = condition_params[self.CONST_CONDITION_VALIDATION_FUNCTION_CONF_KEY]\n\n            if validation_function_name not in condition_functions_dict:\n                raise KeyError(f\"Unknwown validation function : {validation_function_name}\")\n\n            # Get Callable from function name\n            validation_function: Callable = condition_functions_dict[validation_function_name]\n\n            # Create Condition instance\n            condition_instance: StandardCondition = StandardCondition(\n                condition_id=condition_id,\n                description=condition_params[self.CONST_CONDITION_DESCRIPTION_CONF_KEY],\n                validation_function=validation_function,\n                validation_function_parameters=condition_params[self.CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY],\n            )\n            conditions_dict[condition_id] = condition_instance\n\n        return conditions_dict\n\n    def _adapt_user_rules_dict(self, rules_dict: dict[str, dict[str, Any]]) -&gt; dict[str, dict[str, list[Any]]]:\n        \"\"\"(Protected)\n        Return a dictionary of Rule's instances built from user's rules dictionary.\n\n        Args:\n            rules_dict: User raw rules dictionary.\n\n        Returns:\n            A rules dictionary made from the user input rules.\n        \"\"\"\n        # Var init.\n        rules_dict_formatted: dict[str, list[Any]] = {}\n\n        # Looping throught groups\n        for group_id, group_rules in rules_dict.items():\n            # Initialize list or rules in the group\n            rules_dict_formatted[group_id] = []\n\n            # Looping through rules (inside a group)\n            for rule_id, rule_dict in group_rules.items():\n                # Get action function\n                action = rule_dict[\"action\"]\n\n                # Trigger if not **kwargs\n                if \"kwargs\" not in inspect.signature(action).parameters:\n                    raise KeyError(f\"The action function {action} must have a '**kwargs' parameter.\")\n\n                # Create Rule instance\n                rule = Rule(\n                    set_id=self.CONST_DFLT_RULE_SET_ID,\n                    group_id=group_id,\n                    rule_id=rule_id,\n                    action=action,\n                    action_parameters=rule_dict.get(self.CONST_ACTION_PARAMETERS_CONF_KEY),\n                    condition_exprs={self.CONST_STD_RULE_CONDITION_CONF_KEY: self.CONST_USER_CONDITION_STRING}\n                    if self.CONST_STD_RULE_CONDITION_CONF_KEY in rule_dict\n                    and rule_dict.get(self.CONST_STD_RULE_CONDITION_CONF_KEY) is not None\n                    else {self.CONST_STD_RULE_CONDITION_CONF_KEY: None},\n                    std_condition_instances={\n                        self.CONST_USER_CONDITION_STRING: StandardCondition(\n                            condition_id=self.CONST_USER_CONDITION_STRING,\n                            description=\"Automatic description\",\n                            validation_function=rule_dict.get(self.CONST_STD_RULE_CONDITION_CONF_KEY),\n                            validation_function_parameters=rule_dict.get(\n                                self.CONST_CONDITION_VALIDATION_PARAMETERS_CONF_KEY\n                            ),\n                        )\n                    },\n                    condition_factory_mapping=self.BUILTIN_FACTORY_MAPPING,\n                )\n                rules_dict_formatted[group_id].append(rule)\n\n        return {self.CONST_DFLT_RULE_SET_ID: rules_dict_formatted}\n\n    def __str__(self) -&gt; str:\n        \"\"\"Object human string representation (called by str()).\n\n        Returns:\n            A string representation of the instance.\n        \"\"\"\n        # Vars init.\n        attrs_str: str = \"\"\n\n        # Get some instance attributes infos\n        class_name: str = self.__class__.__name__\n        attrs: list[tuple[str, Any]] = [\n            attr\n            for attr in inspect.getmembers(self)\n            if not (\n                attr[0].startswith(\"_\")\n                or attr[0].startswith(\"CONST_\")\n                or isinstance(attr[1], (FunctionType, MethodType))\n            )\n        ]\n\n        # Build string representation\n        for attr, val in attrs:\n            attrs_str += f\"{attr}={str(val)}, \"\n\n        return f\"{class_name}({attrs_str})\"\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.__init__","title":"<code>__init__(*, rules_dict=None, config_path=None)</code>","text":"<p>Initialize the rules.</p> <p>2 possibilities: either 'rules_dict', or 'config_path', not both.</p> <p>Parameters:</p> Name Type Description Default <code>rules_dict</code> <code>dict[str, dict[str, Any]] | None</code> <p>A dictionary containing the rules' definitions.</p> <code>None</code> <code>config_path</code> <code>str | None</code> <p>Path of a directory containing the YAML files.</p> <code>None</code> <p>Raises:</p> Type Description <code>KeyError</code> <p>Key not found.</p> <code>TypeError</code> <p>Wrong type.</p> Source code in <code>arta/_engine.py</code> <pre><code>def __init__(\n    self,\n    *,\n    rules_dict: dict[str, dict[str, Any]] | None = None,\n    config_path: str | None = None,\n) -&gt; None:\n    \"\"\"Initialize the rules.\n\n    2 possibilities: either 'rules_dict', or 'config_path', not both.\n\n    Args:\n        rules_dict: A dictionary containing the rules' definitions.\n        config_path: Path of a directory containing the YAML files.\n\n    Raises:\n        KeyError: Key not found.\n        TypeError: Wrong type.\n    \"\"\"\n    # Var init.\n    factory_mapping_classes: dict[str, type[BaseCondition]] = {}\n    std_condition_instances: dict[str, StandardCondition] = {}\n\n    if config_path is not None and rules_dict is not None:\n        raise ValueError(\"RulesEngine takes only one parameter: 'rules_dict' or 'config_path', not both.\")\n\n    # Init. default parsing_error_strategy (probably not needed because already defined elsewhere)\n    self._parsing_error_strategy: ParsingErrorStrategy = ParsingErrorStrategy.RAISE\n\n    # Initialize directly with a rules dict\n    if rules_dict is not None:\n        # Data validation\n        RulesDict.parse_obj(rules_dict)\n\n        # Edge cases data validation\n        if not isinstance(rules_dict, dict):\n            raise TypeError(f\"'rules_dict' must be dict type, not '{type(rules_dict)}'\")\n        elif len(rules_dict) == 0:\n            raise KeyError(\"'rules_dict' couldn't be empty.\")\n\n        # Attribute definition\n        self.rules: dict[str, dict[str, list[Rule]]] = self._adapt_user_rules_dict(rules_dict)\n\n    # Initialize with a config_path\n    elif config_path is not None:\n        # Load config in attribute\n        config_dict: dict[str, Any] = load_config(config_path)\n\n        # Data validation\n        config: Configuration = Configuration(**config_dict)\n\n        if config.parsing_error_strategy is not None:\n            # Set parsing error handling strategy from config\n            self._parsing_error_strategy = ParsingErrorStrategy(config.parsing_error_strategy)\n\n        # dict of available action functions (k: function name, v: function object)\n        action_modules: list[str] = config.actions_source_modules\n        action_functions: dict[str, Callable] = self._get_object_from_source_modules(action_modules)\n\n        # dict of available standard condition functions (k: function name, v: function object)\n        condition_modules: list[str] = (\n            config.conditions_source_modules if config.conditions_source_modules is not None else []\n        )\n        std_condition_functions: dict[str, Callable] = self._get_object_from_source_modules(condition_modules)\n\n        # Dictionary of condition instances (k: condition id, v: instance), built from config data\n        if len(std_condition_functions) &gt; 0:\n            std_condition_instances = self._build_std_conditions(\n                config=config.dict(), condition_functions_dict=std_condition_functions\n            )\n\n        # User-defined/custom conditions\n        if config.condition_factory_mapping is not None and config.custom_classes_source_modules is not None:\n            # dict of custom condition classes (k: classe name, v: class object)\n            custom_condition_classes: dict[str, type[BaseCondition]] = self._get_object_from_source_modules(\n                config.custom_classes_source_modules\n            )\n\n            # Build a factory mapping dictionary (k: conf key, v:class object)\n            factory_mapping_classes.update(\n                {\n                    conf_key: custom_condition_classes[class_name]\n                    for conf_key, class_name in config.condition_factory_mapping.items()\n                }\n            )\n\n        # Arta built-in conditions\n        factory_mapping_classes.update(self.BUILTIN_FACTORY_MAPPING)\n\n        # Attribute definition\n        self.rules = self._build_rules(\n            std_condition_instances=std_condition_instances,\n            action_functions=action_functions,\n            config=config.dict(),\n            factory_mapping_classes=factory_mapping_classes,\n        )\n    else:\n        raise ValueError(\"RulesEngine needs a parameter: 'rule_dict' or 'config_path'.\")\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.__str__","title":"<code>__str__()</code>","text":"<p>Object human string representation (called by str()).</p> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the instance.</p> Source code in <code>arta/_engine.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Object human string representation (called by str()).\n\n    Returns:\n        A string representation of the instance.\n    \"\"\"\n    # Vars init.\n    attrs_str: str = \"\"\n\n    # Get some instance attributes infos\n    class_name: str = self.__class__.__name__\n    attrs: list[tuple[str, Any]] = [\n        attr\n        for attr in inspect.getmembers(self)\n        if not (\n            attr[0].startswith(\"_\")\n            or attr[0].startswith(\"CONST_\")\n            or isinstance(attr[1], (FunctionType, MethodType))\n        )\n    ]\n\n    # Build string representation\n    for attr, val in attrs:\n        attrs_str += f\"{attr}={str(val)}, \"\n\n    return f\"{class_name}({attrs_str})\"\n</code></pre>"},{"location":"api_reference/#arta._engine.RulesEngine.apply_rules","title":"<code>apply_rules(input_data, *, rule_set=None, verbose=False, **kwargs)</code>","text":"<p>Apply the rules and return results.</p> <p>For each rule group of a given rule set, rules are applied sequentially, The loop is broken when a rule is applied (an action is triggered). Then, the next rule group is evaluated. And so on...</p> <p>This means that the order of the rules in the configuration file (e.g., rules.yaml) is meaningful.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Input data to apply rules on.</p> required <code>rule_set</code> <code>str | None</code> <p>Apply rules associated with the specified rule set.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>If True, add extra ids (group_id, rule_id) for result explicability.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the rule groups' results (k: group id, v: action result).</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>Wrong type.</p> <code>KeyError</code> <p>Key not found.</p> Source code in <code>arta/_engine.py</code> <pre><code>def apply_rules(\n    self, input_data: dict[str, Any], *, rule_set: str | None = None, verbose: bool = False, **kwargs: Any\n) -&gt; dict[str, Any]:\n    \"\"\"Apply the rules and return results.\n\n    For each rule group of a given rule set, rules are applied sequentially,\n    The loop is broken when a rule is applied (an action is triggered).\n    Then, the next rule group is evaluated.\n    And so on...\n\n    This means that the order of the rules in the configuration file\n    (e.g., rules.yaml) is meaningful.\n\n    Args:\n        input_data: Input data to apply rules on.\n        rule_set: Apply rules associated with the specified rule set.\n        verbose: If True, add extra ids (group_id, rule_id) for result explicability.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        A dictionary containing the rule groups' results (k: group id, v: action result).\n\n    Raises:\n        TypeError: Wrong type.\n        KeyError: Key not found.\n    \"\"\"\n    # Input_data validation\n    if not isinstance(input_data, dict):\n        raise TypeError(f\"'input_data' must be dict type, not '{type(input_data)}'\")\n    elif len(input_data) == 0:\n        raise KeyError(\"'input_data' couldn't be empty.\")\n\n    # Var init.\n    input_data_copy: dict[str, Any] = copy.deepcopy(input_data)\n\n    # Prepare the result key\n    input_data_copy[\"output\"] = {}\n\n    # If there is no given rule set param. and there is only one rule set in self.rules\n    # and its value is 'default_rule_set', look for this one (rule_set='default_rule_set')\n    if rule_set is None and len(self.rules) == 1 and self.rules.get(self.CONST_DFLT_RULE_SET_ID) is not None:\n        rule_set = self.CONST_DFLT_RULE_SET_ID\n\n    # Check if given rule set is in self.rules?\n    if rule_set not in self.rules:\n        raise KeyError(\n            f\"Rule set '{rule_set}' not found in the rules, available rule sets are : {list(self.rules.keys())}.\"\n        )\n\n    # Var init.\n    results_dict: dict[str, Any] = {\"verbosity\": {\"rule_set\": rule_set, \"results\": []}}\n\n    # Groups' loop\n    for group_id, rules_list in self.rules[rule_set].items():\n        # Initialize result of the rule group with None\n        results_dict[group_id] = None\n\n        # Rules' loop (inside a group)\n        for rule in rules_list:\n            # Apply rules\n            action_result, rule_details = rule.apply(\n                input_data_copy, parsing_error_strategy=self._parsing_error_strategy, **kwargs\n            )\n\n            # Check if the rule has been applied (= action activated)\n            if \"action_result\" in rule_details:\n                # Save result and details\n                results_dict[group_id] = action_result\n                results_dict[\"verbosity\"][\"results\"].append(rule_details)\n\n                # Update input data with current result with key 'output' (can be used in next rules)\n                input_data_copy[\"output\"][group_id] = copy.deepcopy(results_dict[group_id])\n\n                # We can only have one result per group =&gt; break when \"action_result\" in rule_details\n                break\n\n    # Handling non-verbose mode\n    if not verbose:\n        results_dict.pop(\"verbosity\")\n\n    return results_dict\n</code></pre>"},{"location":"api_reference/#conditionpy","title":"condition.py","text":"<p>Condition implementation.</p> <p>Classes: BaseCondition, StandardCondition, SimpleCondition</p>"},{"location":"api_reference/#arta.condition.BaseCondition","title":"<code>BaseCondition</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class of a Condition object (Strategy Pattern).</p> <p>Is an abstract class and can't be instantiated.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class BaseCondition(ABC):\n    \"\"\"Base class of a Condition object (Strategy Pattern).\n\n    Is an abstract class and can't be instantiated.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    # Class constants\n    CONST_CONDITION_DATA_LABEL: str = \"Custom condition data (not needed)\"\n    CONDITION_ID_PATTERN: str = UPPERCASE_WORD_PATTERN\n\n    def __init__(\n        self,\n        condition_id: str,\n        description: str,\n        validation_function: Callable | None = None,\n        validation_function_parameters: dict[str, Any] | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize attributes.\n\n        Args:\n            condition_id: Id of a condition.\n            description: Description of a condition.\n            validation_function: Validation function of a condition.\n            validation_function_parameters: Arguments of the validation function.\n        \"\"\"\n        self._condition_id = condition_id  # NOSONAR\n        self._description = description  # NOSONAR\n        self._validation_function = validation_function  # NOSONAR\n        self._validation_function_parameters = validation_function_parameters  # NOSONAR\n\n    @classmethod\n    def extract_condition_ids_from_expression(cls, condition_expr: str | None = None) -&gt; set[str]:\n        \"\"\"Get the condition ids from a string (e.g., UPPERCASE words).\n\n        E.g., CONDITION_1 and not CONDITION_2\n\n        Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.\n\n        Args:\n            condition_expr: A boolean expression (string).\n\n        Returns:\n            A set of extracted condition ids.\n        \"\"\"\n        cond_ids: set[str] = set()\n\n        if condition_expr is not None:\n            cond_ids = set(re.findall(cls.CONDITION_ID_PATTERN, condition_expr))\n\n        return cond_ids\n\n    @abstractmethod\n    def verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"(Abstract)\n        Return True if the condition is verified.\n\n        Args:\n            input_data: Input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.__init__","title":"<code>__init__(condition_id, description, validation_function=None, validation_function_parameters=None)</code>","text":"<p>Initialize attributes.</p> <p>Parameters:</p> Name Type Description Default <code>condition_id</code> <code>str</code> <p>Id of a condition.</p> required <code>description</code> <code>str</code> <p>Description of a condition.</p> required <code>validation_function</code> <code>Callable | None</code> <p>Validation function of a condition.</p> <code>None</code> <code>validation_function_parameters</code> <code>dict[str, Any] | None</code> <p>Arguments of the validation function.</p> <code>None</code> Source code in <code>arta/condition.py</code> <pre><code>def __init__(\n    self,\n    condition_id: str,\n    description: str,\n    validation_function: Callable | None = None,\n    validation_function_parameters: dict[str, Any] | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize attributes.\n\n    Args:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n    self._condition_id = condition_id  # NOSONAR\n    self._description = description  # NOSONAR\n    self._validation_function = validation_function  # NOSONAR\n    self._validation_function_parameters = validation_function_parameters  # NOSONAR\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.extract_condition_ids_from_expression","title":"<code>extract_condition_ids_from_expression(condition_expr=None)</code>  <code>classmethod</code>","text":"<p>Get the condition ids from a string (e.g., UPPERCASE words).</p> <p>E.g., CONDITION_1 and not CONDITION_2</p> <p>Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.</p> <p>Parameters:</p> Name Type Description Default <code>condition_expr</code> <code>str | None</code> <p>A boolean expression (string).</p> <code>None</code> <p>Returns:</p> Type Description <code>set[str]</code> <p>A set of extracted condition ids.</p> Source code in <code>arta/condition.py</code> <pre><code>@classmethod\ndef extract_condition_ids_from_expression(cls, condition_expr: str | None = None) -&gt; set[str]:\n    \"\"\"Get the condition ids from a string (e.g., UPPERCASE words).\n\n    E.g., CONDITION_1 and not CONDITION_2\n\n    Warning: implementation is based on the current class constant CONDITION_SPLIT_PATTERN.\n\n    Args:\n        condition_expr: A boolean expression (string).\n\n    Returns:\n        A set of extracted condition ids.\n    \"\"\"\n    cond_ids: set[str] = set()\n\n    if condition_expr is not None:\n        cond_ids = set(re.findall(cls.CONDITION_ID_PATTERN, condition_expr))\n\n    return cond_ids\n</code></pre>"},{"location":"api_reference/#arta.condition.BaseCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>  <code>abstractmethod</code>","text":"<p>(Abstract) Return True if the condition is verified.</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> Source code in <code>arta/condition.py</code> <pre><code>@abstractmethod\ndef verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"(Abstract)\n    Return True if the condition is verified.\n\n    Args:\n        input_data: Input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api_reference/#arta.condition.SimpleCondition","title":"<code>SimpleCondition</code>","text":"<p>             Bases: <code>BaseCondition</code></p> <p>Class implementing a built-in simple condition.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class SimpleCondition(BaseCondition):\n    \"\"\"Class implementing a built-in simple condition.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    # Class constants\n    CONST_CUSTOM_CONDITION_DATA_LABEL: str = \"Simple condition data (not needed)\"\n    CONDITION_ID_PATTERN: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-0-9!=&lt;&gt;\\\"NTF\\.]*)\"\n\n    def verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"Return True if the condition is verified.\n\n        Example of a unitary simple condition to be verified: 'input.age&gt;=100'\n\n        Args:\n            input_data: Request or input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n\n        Raises:\n            AttributeError: Check the validation function or its parameters.\n        \"\"\"\n        bool_var: bool = False\n        unitary_expr: str = self._condition_id\n\n        data_path_patt: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-\\.]*)\"\n\n        # Retrieve only the data path\n        path_matches: list[str] = re.findall(data_path_patt, unitary_expr)\n\n        if len(path_matches) == 1:\n            # Regular case: we have a data_path\n            data_path: str = path_matches[0]\n\n            # Read data from its path\n            data = parse_dynamic_parameter(  # noqa\n                parameter=data_path, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n            )\n\n            # Replace with the variable name in the expression\n            eval_expr: str = unitary_expr.replace(data_path, \"data\")\n\n            # Evaluate the expression\n            try:\n                bool_var = eval(eval_expr)  # noqa\n            except TypeError:\n                # Ignore evaluation --&gt; False\n                pass\n\n        elif parsing_error_strategy == ParsingErrorStrategy.RAISE:\n            # Raise an error because of no match for a data path\n            raise ConditionExecutionError(f\"Error when verifying simple condition: '{unitary_expr}'\")\n\n        else:\n            # Other case: ignore, default value =&gt; return False\n            pass\n\n        return bool_var\n</code></pre>"},{"location":"api_reference/#arta.condition.SimpleCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>","text":"<p>Return True if the condition is verified.</p> <p>Example of a unitary simple condition to be verified: 'input.age&gt;=100'</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Request or input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Check the validation function or its parameters.</p> Source code in <code>arta/condition.py</code> <pre><code>def verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"Return True if the condition is verified.\n\n    Example of a unitary simple condition to be verified: 'input.age&gt;=100'\n\n    Args:\n        input_data: Request or input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n\n    Raises:\n        AttributeError: Check the validation function or its parameters.\n    \"\"\"\n    bool_var: bool = False\n    unitary_expr: str = self._condition_id\n\n    data_path_patt: str = r\"(?:input\\.|output\\.)(?:[a-z_\\-\\.]*)\"\n\n    # Retrieve only the data path\n    path_matches: list[str] = re.findall(data_path_patt, unitary_expr)\n\n    if len(path_matches) == 1:\n        # Regular case: we have a data_path\n        data_path: str = path_matches[0]\n\n        # Read data from its path\n        data = parse_dynamic_parameter(  # noqa\n            parameter=data_path, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n        )\n\n        # Replace with the variable name in the expression\n        eval_expr: str = unitary_expr.replace(data_path, \"data\")\n\n        # Evaluate the expression\n        try:\n            bool_var = eval(eval_expr)  # noqa\n        except TypeError:\n            # Ignore evaluation --&gt; False\n            pass\n\n    elif parsing_error_strategy == ParsingErrorStrategy.RAISE:\n        # Raise an error because of no match for a data path\n        raise ConditionExecutionError(f\"Error when verifying simple condition: '{unitary_expr}'\")\n\n    else:\n        # Other case: ignore, default value =&gt; return False\n        pass\n\n    return bool_var\n</code></pre>"},{"location":"api_reference/#arta.condition.StandardCondition","title":"<code>StandardCondition</code>","text":"<p>             Bases: <code>BaseCondition</code></p> <p>Class implementing a built-in condition, named standard condition.</p> <p>Attributes:</p> Name Type Description <code>condition_id</code> <p>Id of a condition.</p> <code>description</code> <p>Description of a condition.</p> <code>validation_function</code> <p>Validation function of a condition.</p> <code>validation_function_parameters</code> <p>Arguments of the validation function.</p> Source code in <code>arta/condition.py</code> <pre><code>class StandardCondition(BaseCondition):\n    \"\"\"Class implementing a built-in condition, named standard condition.\n\n    Attributes:\n        condition_id: Id of a condition.\n        description: Description of a condition.\n        validation_function: Validation function of a condition.\n        validation_function_parameters: Arguments of the validation function.\n    \"\"\"\n\n    def verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n        \"\"\"Return True if the condition is verified.\n\n        Example of a unitary standard condition: CONDITION_1\n\n        Args:\n            input_data: Request or input data to apply rules on.\n            parsing_error_strategy: Error handling strategy for parameter parsing.\n            **kwargs: For user extra arguments.\n\n        Returns:\n            True if the condition is verified, otherwise False.\n\n        Raises:\n            AttributeError: Check the validation function or its parameters.\n        \"\"\"\n        if self._validation_function is None:\n            raise AttributeError(\"Validation function should not be None\")\n\n        if self._validation_function_parameters is None:\n            raise AttributeError(\"Validation function parameters should not be None\")\n\n        # Parse dynamic parameters\n        parameters: dict[str, Any] = {}\n\n        for key, value in self._validation_function_parameters.items():\n            parameters[key] = parse_dynamic_parameter(\n                parameter=value, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n            )\n\n        # Run validation_function\n        return self._validation_function(**parameters)\n</code></pre>"},{"location":"api_reference/#arta.condition.StandardCondition.verify","title":"<code>verify(input_data, parsing_error_strategy, **kwargs)</code>","text":"<p>Return True if the condition is verified.</p> <p>Example of a unitary standard condition: CONDITION_1</p> <p>Parameters:</p> Name Type Description Default <code>input_data</code> <code>dict[str, Any]</code> <p>Request or input data to apply rules on.</p> required <code>parsing_error_strategy</code> <code>ParsingErrorStrategy</code> <p>Error handling strategy for parameter parsing.</p> required <code>**kwargs</code> <code>Any</code> <p>For user extra arguments.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the condition is verified, otherwise False.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>Check the validation function or its parameters.</p> Source code in <code>arta/condition.py</code> <pre><code>def verify(self, input_data: dict[str, Any], parsing_error_strategy: ParsingErrorStrategy, **kwargs: Any) -&gt; bool:\n    \"\"\"Return True if the condition is verified.\n\n    Example of a unitary standard condition: CONDITION_1\n\n    Args:\n        input_data: Request or input data to apply rules on.\n        parsing_error_strategy: Error handling strategy for parameter parsing.\n        **kwargs: For user extra arguments.\n\n    Returns:\n        True if the condition is verified, otherwise False.\n\n    Raises:\n        AttributeError: Check the validation function or its parameters.\n    \"\"\"\n    if self._validation_function is None:\n        raise AttributeError(\"Validation function should not be None\")\n\n    if self._validation_function_parameters is None:\n        raise AttributeError(\"Validation function parameters should not be None\")\n\n    # Parse dynamic parameters\n    parameters: dict[str, Any] = {}\n\n    for key, value in self._validation_function_parameters.items():\n        parameters[key] = parse_dynamic_parameter(\n            parameter=value, input_data=input_data, parsing_error_strategy=parsing_error_strategy\n        )\n\n    # Run validation_function\n    return self._validation_function(**parameters)\n</code></pre>"},{"location":"glossary/","title":"Glossary","text":"Concept Definition action A task which is executed when conditions are verified. action function A callable object called to execute the action. action parameter Parameter of an action function. condition A condition to be verified before executing an action. condition id Identifier of a single condition (must be in CAPITAL LETTER). condition expression A boolean expression combining several conditions (meaning several condition id). condition function A callable object called to be verified therefore it returns a boolean. condition parameter Parameter of a condition/validation function. custom condition A user-defined condition. rule A set of conditions combined to one action. rule group A group of rules (usually sharing a common context). rule id Identifier of a single rule. rule set A set of rule groups (mostly one: <code>default_rule_set</code>). simple condition A built-in very simple condition. standard condition The regular built-in condition. validation function Same thing as a condition function."},{"location":"home/","title":"Home","text":"<p> Arta is a simple python rules engine designed for and by python developers </p> <p> </p>"},{"location":"home/#welcome-to-the-documentation","title":"Welcome to the documentation","text":"<ul> <li>Want to discover what is Arta?  Get Started</li> <li>Want to know how to use it?  User Guide</li> </ul> <p>New feature</p> <p>Check out the new and very convenient feature called the simple condition. A new and lightweight way of configuring your rules' conditions.</p> <p>Arta is automatically tested with:</p> <p></p> <p>Releases</p> <p>Want to see last updates, check the Release notes </p> <p>Pydantic 2</p> <p>Arta is now working with Pydantic 2! And of course, Pydantic 1 as well.</p>"},{"location":"how_to/","title":"How to","text":"<p>Ensure that you have correctly installed Arta before, check the Installation page </p>"},{"location":"how_to/#simple-condition","title":"Simple condition","text":"<p>Beta feature</p> <p>Simple condition is still a beta feature, some cases could not work as designed.</p> <p>Simple conditions are a new and straightforward way of configuring your conditions.</p> <p>It simplifies a lot your rules by:</p> <ul> <li>Removing the use of a <code>conditions.py</code> module (no validation functions needed).</li> <li>Removing the <code>conditions:</code> configuration key in your YAML files.</li> </ul> <p>Note</p> <p>With the simple conditions you use straight boolean expressions directly in your configuration.</p> <p>It is easyer to read and maintain </p> <p>The configuration key here is:</p> <p><code>simple_condition:</code></p> <p>Example :</p> <pre><code>---\nrules:\n  default_rule_set:\n    admission:\n      ADM_OK:\n        simple_condition: input.power==\"strength\" or input.power==\"fly\"\n        action: set_admission\n        action_parameters:\n          value: OK \n      ADM_TO_BE_CHECKED:\n        simple_condition: input.age&gt;=150 and input.age!=None\n        action: set_admission\n        action_parameters:\n          value: TO_CHECK     \n      ADM_KO:\n        simple_condition: null\n        action: set_admission\n        action_parameters:\n          value: KO\n\nactions_source_modules:\n  - my_folder.actions  # (1)\n</code></pre> <ol> <li>Contains action function implementations, no need of the key <code>conditions_source_modules</code> here.</li> </ol> <p>How to write a simple condition like:</p> <pre><code>input.power==\"strength\" or input.power==\"fly\"\n</code></pre> <ul> <li>Left operand (data mapping): <ul> <li>You must use one of the following prefixes: <ul> <li><code>input</code> (for input data)</li> <li><code>output</code> (for previous rule's result)</li> </ul> </li> <li>A dot path expression like <code>input.powers.main_power</code>.</li> </ul> </li> <li>Operator: you must use basic python boolean operator (i.e., <code>==, &lt;, &gt;, &lt;=, &gt;=, !=</code>)</li> <li>Right operand: basic python data types (e.i., <code>str, int, None</code>).</li> </ul> <p>Warning</p> <ul> <li>You can't use: <code>is</code> or <code>in</code>, as an operator (yet).</li> <li>You can't use a <code>float</code> as right operand (it's a bug, will be fixed).</li> <li>For strings, don't forget the double quotes <code>\"</code>.</li> </ul> <p>Security concern</p> <p>Python code injection:</p> <p>Because Arta is using the <code>eval()</code> built-in function to evaluate simple conditions:</p> <ul> <li>You should never let the user being able of dynamically define a simple condition (in <code>simple_condition:</code> conf. key).</li> <li>You should verify that write permissions on the YAML files are not allowed when your app is deployed.</li> </ul>"},{"location":"how_to/#standard-condition","title":"Standard condition","text":"<p>It is the first implemented way of using Arta and probably the most powerful.</p> <p>The configuration key here is:</p> <p><code>condition:</code></p> <p>YAML</p> <p>The built-in file format used by Arta for configuration is YAML.</p> <p>Enhancement proposal</p> <p>We are thinking on a design that will allow user-implemented loading of the configuration (e.g., if you prefer using a JSON format). Stay tuned.</p>"},{"location":"how_to/#yaml-file","title":"YAML file","text":"<p>Simple Conditions</p> <p>The following YAML example illustrates how to configure usual standard conditions but there is another and simpler way to do it by using a special feature: the simple condition.</p> <p>Create a YAML file and define your rules like this:</p> <pre><code>---\nrules:\n  default_rule_set:  # (1)\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER  # (2)\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:  # (3)\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:  # (4)\n  - my_folder.conditions\nactions_source_modules:  # (5)\n  - my_folder.actions\n</code></pre> <ol> <li>This is the name of your rule set (i.e., <code>default_rule_set</code> is by default).</li> <li>You can't set a callable object here so we need to use a condition id.</li> <li>The conditions are identified by an id and defined here. The validation function is defined in a user's python module.</li> <li>This is the path of the module where the validation functions are implemented (you must change it).</li> <li>This is the path of the module where the action functions are implemented (you must change it).</li> </ol> <p>Warning</p> <p>Condition ids must be in capital letters here, it is mandatory (e.g., <code>HAS_SCHOOL_AUTHORIZED_POWER</code>).</p> <p>Tip</p> <p>You can split your configuration in multiple YAML files seamlessly in order to keep things clear. Example:</p> <ul> <li>global.yaml =&gt; source modules</li> <li>rules.yaml =&gt; rules' definition</li> <li>conditions.yaml =&gt; conditions' definition</li> </ul> <p>It's very convenient when you have a lot of different rules and conditions in your app.</p>"},{"location":"how_to/#condition-expression","title":"Condition expression","text":"<p>In the above YAML, the following condition expression is intentionally very simple:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <p>The key <code>condition:</code> can take one condition id but also a condition expression (i.e., a boolean expression of condition ids) combining several conditions:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: (HAS_SCHOOL_AUTHORIZED_POWER or SPEAKS_FRENCH) and not(IS_EVIL)\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <p>Warning</p> <p>In that example, you must define the 3 conditions in the configuration:</p> <ul> <li>HAS_SCHOOL_AUTHORIZED_POWER</li> <li>SPEAKS_FRENCH</li> <li>IS_EVIL</li> </ul> <p>Tip</p> <p>Use the condition expressions to keep things simple. Put your conditions in one expression as you can rather than creating several rules </p>"},{"location":"how_to/#functions","title":"Functions","text":"<p>We must create 2 modules:</p> <ul> <li><code>conditions.py</code> -&gt; implements the needed validation functions.</li> <li><code>actions.py</code> -&gt; implements the needed action functions.</li> </ul> <p>Note</p> <p>Module names are arbitrary, you can choose what you want.</p> <p>And implement our 2 needed validation and action functions (the one defined in the configuration file): </p> <p>conditions.py:</p> <pre><code>def has_authorized_super_power(power):\n    return power in [\"strength\", \"fly\", \"immortality\"]\n</code></pre> <p>actions.py:</p> <pre><code>def set_admission(value, **kwargs):  # (1)\n    return {\"is_admitted\": value}\n</code></pre> <ol> <li><code>**kwargs</code> is mandatory here.</li> </ol> <p>Warning</p> <p>Function name and parameters must be the same as the one configured in the YAML file.</p>"},{"location":"how_to/#usage","title":"Usage","text":"<p>Once your configuration file and your functions are ready, you can use it very simply:</p> <pre><code>from arta import RulesEngine\n\ninput_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(config_path=\"path/to/conf/dir\")\n\nresult = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <p>You should get:</p> <p><code>{'check_admission': {'is_admitted': True}}</code></p> <p>API Documentation</p> <p>You can get details on the <code>RulesEngine</code> parameters in the API Reference.</p>"},{"location":"how_to/#concepts","title":"Concepts","text":"<p>Let's go deeper into the concepts.</p>"},{"location":"how_to/#rule-set-and-rule-group","title":"Rule set and rule group","text":"<p>A rule set is composed of rule groups which are themselves composed of rules. We can find this tree structure in the following YAML:</p> <pre><code>---\nrules:\n  default_rule_set:  # (1)\n    check_admission:  # (2)\n      ADMITTED_RULE:  # (3)\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n</code></pre> <ol> <li>This is the id of the rule set.</li> <li>This key define a rule group, we can have many groups (we have only one here for simplicity).</li> <li>This key is a rule id, which identifies rules among others.</li> </ol>"},{"location":"how_to/#rule","title":"Rule","text":"<p>Rule definitions are identified by an id (e.g., <code>ADMITTED_RULE</code>):</p> <pre><code>      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <p>Tip</p> <p>Rule ids are in capital letters for readability only: it is an advised practice.</p> <p>Rules are made of 2 different things:</p> <ul> <li>Condition:</li> </ul> <pre><code>      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre> <ul> <li>Action: </li> </ul> <pre><code>      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n</code></pre>"},{"location":"how_to/#condition-and-action","title":"Condition and Action","text":"<p>Conditions and actions are quite similar in terms of implementation but their goals are different.</p> <p>Both are made of a callable object and some parameters:</p> <ul> <li> <p>Condition keys:</p> <ul> <li> <p><code>validation_function</code>: name of a callable python object that returns a <code>bool</code>, we called this function the validation function (or condition function*).</p> </li> <li> <p><code>condition_parameters</code>: the validation function's arguments.</p> </li> </ul> </li> <li> <p>Action keys:</p> <ul> <li> <p><code>action</code>: name of a callable python object that returns what you want (or does what you want such as: requesting an api, sending an email, etc.), we called this function the action function.</p> </li> <li> <p><code>action_parameters</code>: the action function's arguments.</p> </li> </ul> </li> </ul> <p>Parameter's special syntax</p> <p>The action and condition arguments can have a special syntax: </p> <pre><code>condition_parameters:\n  power: input.super_power\n</code></pre> <p>The string <code>input.super_power</code> is evaluated by the rules engine and it means \"fetch the key <code>super_power</code> in the input data\".</p>"},{"location":"how_to/#dictionary-rules","title":"Dictionary rules","text":"<p>Rules can be configured in a YAML file but they can also be defined by a regular dictionary:</p> Without type hintsWith type hints (&gt;=3.9) <pre><code>from arta import RulesEngine\n\nset_admission = lambda value, **kwargs: {\"is_admitted\": value}\n\nrules = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n\ninput_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(rules_dict=rules)\n\nresult = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <pre><code>from typing import Any, Callable\n\nfrom arta import RulesEngine\n\nset_admission: Callable = lambda value, **kwargs: {\"is_admitted\": value}\n\nrules: dict[str, Any] = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n\ninput_data: dict[str, Any] = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\neng = RulesEngine(rules_dict=rules)\n\nresult: dict[str, Any] = eng.apply_rules(input_data)\n\nprint(result)\n</code></pre> <p>You should get:</p> <pre><code>{'check_admission': {'is_admitted': True}}\n</code></pre> <p>Success</p> <p>Superman is admitted to the superhero school!</p> <p>Well done! By executing this code you have:</p> <ol> <li>Defined an action function (<code>set_admission</code>)</li> <li>Defined a rule set (<code>rules</code>)</li> <li>Used some input data (<code>input_data</code>)</li> <li>Instanciated a rules engine (<code>RulesEngine</code>)</li> <li>Applied the rules on the data and get some results (<code>.apply_rules()</code>)</li> </ol> <p>Note</p> <p>In the code example we used some anonymous/lambda function for simplicity but it could be regular python functions as well.</p> <p>YAML vs Dictionary</p> <p>How to choose between dictionary and configuration?</p> <p>In most cases, you must choose the configuration way of defining your rules.</p> <p>You will improve your rules' maintainability a lot. In some cases like proof-of-concepts or Jupyter notebook works, you will probably be happy with straightforward dictionaries.</p> <p>Arta has plenty more features to discover. If you want to learn more, go to the next chapter: Advanced User Guide.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#python","title":"Python","text":"<p>Compatible with:</p> <p></p>"},{"location":"installation/#pip","title":"pip","text":"<p>In your python environment:</p>"},{"location":"installation/#regular-use","title":"Regular use","text":"<pre><code>pip install arta\n</code></pre>"},{"location":"installation/#development","title":"Development","text":"<pre><code>pip install arta[all]\n</code></pre>"},{"location":"parameters/","title":"Parameters","text":""},{"location":"parameters/#parsing-prefix-keywords","title":"Parsing prefix keywords","text":"<p>There is 2 allowed parsing prefix keywords:</p> <ul> <li><code>input</code>: corresponding to the <code>input_data</code>.</li> <li><code>output</code> : corresponding to the result output data (returned by the <code>apply_rules()</code> method).</li> </ul> <p>Here are examples:</p> <ol> <li><code>input.name</code>: maps to <code>input_data[\"name\"]</code>.</li> <li><code>output.check_admission.is_admitted</code>: maps to <code>result[\"check_admission\"][\"is_admitted\"]</code>.</li> </ol> <p>They both can be used in condition and action parameters.</p> <p>Info</p> <p>A value without any prefix keyword is a constant.</p>"},{"location":"parameters/#parsing-error","title":"Parsing error","text":""},{"location":"parameters/#raise-by-default","title":"Raise by default","text":"<p>By default, errors during condition and action parameters parsing are raised.</p> <p>If we refer to the dictionary example:</p> <pre><code>rules = {\n    \"check_admission\": {\n        \"ADMITTED_RULE\": {\n            \"condition\": lambda power: power in [\"strength\", \"fly\", \"immortality\"],\n            \"condition_parameters\": {\"power\": \"input.super_power\"}, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": True},\n        },\n        \"DEFAULT_RULE\": {\n            \"condition\": None,\n            \"condition_parameters\": None, \n            \"action\": set_admission,\n            \"action_parameters\": {\"value\": False},\n        },\n    }\n}\n</code></pre> <p>With modified data like:</p> <pre><code>input_data = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n</code></pre> <p>By default we will get a <code>KeyError</code> exception during the execution of the <code>apply_rules()</code> method because of <code>power</code> vs <code>super_power</code>.</p>"},{"location":"parameters/#ignore","title":"Ignore","text":"<p>You can change the by default raising behavior of the parameter's parsing.</p> <p>Two ways are possible:</p> <ul> <li>At the configuration level: impacts all the parameters.</li> <li>At the parameter's level. </li> </ul>"},{"location":"parameters/#configuration-level","title":"Configuration level","text":"<p>You just have to add the following key somewhere in your configuration:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n\nparsing_error_strategy: ignore  # (1)\n</code></pre> <ol> <li><code>parsing_error_strategy</code> has two possible values: <code>raise</code> and <code>ignore</code>.</li> </ol> <p>It will affect all the parameters.</p>"},{"location":"parameters/#parameter-level","title":"Parameter level","text":"<p>Quick Sum Up</p> <ul> <li><code>input.super_power?</code>: set the value to <code>None</code></li> <li><code>input.super_power?no_power</code>: set the value to <code>no_power</code></li> <li><code>input.super_power!</code>: force raise exception (case when ignore is set by default)</li> </ul> <p>You can also handle more precisely that aspect at parameter's level:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power?  # (1)\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n</code></pre> <ol> <li>Have you noticed the '?' ? If there is a <code>KeyError</code> when reading, <code>power</code> will be set to <code>None</code> rather than raising the exception.</li> </ol> <p>Info</p> <p>You can enforce raising exceptions at parameter's level with <code>!</code>.</p> <pre><code>power: input.super_power!\n</code></pre>"},{"location":"parameters/#default-value-parameter-level","title":"Default value (parameter level)","text":"<p>Finally, you can set a default value at parameter's level. This value will be used if there is an exception during parsing:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power?no_power  # (1)\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n</code></pre> <ol> <li>If there is an exception during parsing, <code>power</code> will be set to <code>\"no_power\"</code>.</li> </ol> <p>Good to know</p> <p>Parameter's level is overriding configuration level.</p>"},{"location":"rule_sets/","title":"Rule sets","text":"<p>Rule sets are a convenient way to separate your business rules into different collections. </p> <p>Doing so increases the rules' maintainability because of a better organization and fully uncoupled rules.</p> <p>Tip</p> <p>Rule sets are very usefull when you have a lot of rules.</p> <p>Info</p> <p>Most of the time, you won't need to handle different rule sets and will only use the default one: <code>default_rule_set</code>.</p> <p>The good news is that different rule sets can be used seamlessly with the same rules engine instance </p> <p>Let's take the following example:</p> <p>Based on that example, imagine that you need to add some rules about something totally different than the superhero school. Let's say rules for a dinosaur school.</p>"},{"location":"rule_sets/#configuration","title":"Configuration","text":"<p>Update your configuration by adding a new rule set: <code>dinosaur_school_set</code></p> <pre><code>---\nrules:\n  superhero_school_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n  dinosaur_school_set:  # (1)\n    food_habit:\n      HERBIVOROUS:\n        condition: not(IS_EATING_MEAT)\n        action: send_mail_to_cook\n        action_parameters:\n          meal: \"plant\"\n      CARNIVOROUS:\n        condition: null\n        action: send_mail_to_cook\n        action_parameters:\n          meal: \"meat\"\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n  IS_EATING_MEAT:  # (2)\n    description: \"Is dinosaur eating meat?\"\n    validation_function: is_eating_meat\n    condition_parameters:\n      power: input.diet.regular_food\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules:\n  - my_folder.actions\n</code></pre> <ol> <li>Add your new set of rules under the <code>rules</code> key</li> <li>Regular condition configuration, nothing new here</li> </ol> <p>Good to know</p> <p>You can define your rule sets into different YAML files (under the <code>rules</code> key in each).</p>"},{"location":"rule_sets/#usage","title":"Usage","text":"<p>Now that your rule sets are defined (and assuming that your condition and action functions are implemented in the right modules), you can easily use them:</p> <pre><code>from arta import RulesEngine\n\ninput_data_1 = {\n    \"id\": 1,\n    \"name\": \"Superman\",\n    \"civilian_name\": \"Clark Kent\",\n    \"age\": None,\n    \"city\": \"Metropolis\",\n    \"language\": \"french\",\n    \"super_power\": \"fly\",\n    \"favorite_meal\": \"Spinach\",\n    \"secret_weakness\": \"Kryptonite\",\n    \"weapons\": [],\n}\n\ninput_data_2 = {\n    \"id\": 1,\n    \"name\": \"Diplodocus\",\n    \"age\": 152000000,\n    \"length\": 31,\n    \"area\": \"north_america\",\n    \"diet\": {\n        \"regular_food\": \"plants\",\n    },\n}\n\neng = RulesEngine(config_path=\"path/to/conf/dir\")\n\nsuperhero_result = eng.apply_rules(input_data_1, rule_set=\"superhero_school_set\")  # (1)\n\ndinosaur_result = eng.apply_rules(input_data_2, rule_set=\"dinosaur_school_set\")\n</code></pre> <ol> <li>Select the rule set that you want to use when applying rules on your input data.</li> </ol> <p>Good to know</p> <p>Input data can be different or the same among the rule sets. It depends on the use case.</p>"},{"location":"rule_sets/#object-oriented-model","title":"Object-Oriented Model","text":"<pre><code>classDiagram\n    rule_set \"1\" -- \"1..*\" rule_group\n    rule_group \"1\" -- \"1..*\" rule\n    rule \"1..*\" -- \"0..*\" condition\n    rule \"1..*\" -- \"1\" action</code></pre>"},{"location":"special_conditions/","title":"Special conditions","text":""},{"location":"special_conditions/#custom-condition","title":"Custom condition","text":"<p>Custom conditions are user-defined conditions. </p> <p>A custom condition will impact the atomic evaluation of each conditions (i.e., condition ids).</p> <p>Vocabulary</p> <p>To be more precise, a condition expression is something like:</p> <pre><code>CONDITION_1 and CONDITION_2\n</code></pre> <p>In that example, the condition expression is made of 2 conditions whose condition ids are:</p> <ul> <li>CONDITION_1</li> <li>CONDITION_2</li> </ul> <p>With the built-in condition (also named standard condition), condition ids map to validation functions and condition parameters but we can change that with a brand new custom condition.</p> <p>A custom condition example:</p> <pre><code>my_condition: NAME_JOHN and AGE_42\n</code></pre> <p>Remember</p> <p>condition ids have to be in CAPITAL LETTERS.</p> <p>Imagine you want it to be interpreted as (pseudo-code):</p> <pre><code>if input.name == \"john\" and input.age == \"42\":\n    # Do something\n    ...\n</code></pre> <p>With the custom conditions it's quite simple to implement.</p> <p>Why using a custom condition?</p> <p>The main goal is to simplify handling of recurrent conditions (e.i., \"recurrent\" meaning very similar conditions).</p>"},{"location":"special_conditions/#class-implementation","title":"Class implementation","text":"<p>First, create a class inheriting from <code>BaseCondtion</code> and implement the <code>verify()</code> method as you want/need:</p> <pre><code>from typing import Any\n\nfrom arta.condition import BaseCondition\nfrom arta.utils import ParsingErrorStrategy\n\n\nclass MyCondition(BaseCondition):\n    def verify(\n        self,\n        input_data: dict[str, Any],\n        parsing_error_strategy: ParsingErrorStrategy,\n        **kwargs: Any\n    ) -&gt; bool:\n\n        field, value = tuple(self.condition_id.split(\"_\"))\n\n        return input_data[field.lower()] == value.lower()\n</code></pre> <p>self.condition_id</p> <p><code>self.condition_id</code> will be <code>NAME_JOHN</code> for the first condition and <code>AGE_42</code> for the second.</p> <p>Good to know</p> <p>The <code>parsing_error_strategy</code> can be used by the developer to adapt exception handling behavior. Possible values:</p> <pre><code>ParsingErrorStrategy.RAISE\nParsingErrorStrategy.IGNORE\nParsingErrorStrategy.DEFAULT_VALUE\n</code></pre>"},{"location":"special_conditions/#configuration","title":"Configuration","text":"<p>Last thing to do is to add your new custom condition in the configuration:</p> <pre><code>---\nrules:\n  default_rule_set:\n    check_admission:\n      ADMITTED_RULE:\n        condition: HAS_SCHOOL_AUTHORIZED_POWER\n        my_condition: NAME_JOHN and AGE_42  # (1)\n        action: set_admission\n        action_parameters:\n          value: true\n      DEFAULT_RULE:\n        condition: null\n        action: set_admission\n        action_parameters:\n          value: false\n\nconditions:\n  HAS_SCHOOL_AUTHORIZED_POWER:\n    description: \"Does applicant have a school authorized power?\"\n    validation_function: has_authorized_super_power\n    condition_parameters:\n      power: input.super_power\n\nconditions_source_modules:\n  - my_folder.conditions\nactions_source_modules: \n  - my_folder.actions\n\ncustom_classes_source_modules:\n  - dir.to.my_module  # (2)\ncondition_factory_mapping:\n  my_condition: MyCondition # (3)\n</code></pre> <ol> <li>Order is important, here it will evaluate <code>condition</code> then <code>my_condition</code>. Order is arbitrary.</li> <li>List of the modules containing custom classes</li> <li>Mapping between condition keys (<code>my_condition</code>) and custom classes (<code>MyCondition</code>)</li> </ol>"},{"location":"special_conditions/#class-diagram","title":"Class diagram","text":"<p>It is based on the following strategy pattern:</p> <pre><code>classDiagram\n    note for MyCondition \"This is a custom condition class\"\n    RulesEngine \"1\" -- \"1..*\" Rule\n    Rule \"1..*\" -- \"0..*\" BaseCondition\n    BaseCondition &lt;|-- StandardCondition\n    BaseCondition &lt;|-- SimpleCondition\n    BaseCondition &lt;|-- MyCondition\n    class RulesEngine{\n        +rules\n        +apply_rules()\n    }\n    class Rule {\n        #set_id\n        #group_id\n        #rule_id\n        #condition_exprs\n        #action\n        #action_parameters\n        +apply()\n    }\n    class BaseCondition {\n        &lt;&lt;abstract&gt;&gt;\n        #condition_id\n        #description\n        #validation_function\n        #validation_function_parameters\n        +verify()\n    }</code></pre> <p>Good to know</p> <p>The class <code>StandardCondition</code> is the built-in implementation of a condition.</p>"},{"location":"why/","title":"Why use Arta?","text":"<p>There is one main reason for using Arta and it was the main goal of its development: </p> <p>Increase business rules maintainability.</p> <p>In other words, facilitate rules handling in a python app.</p>"},{"location":"why/#before-arta","title":"Before Arta","text":"<p>Rules in code can rapidly become a headache, kind of spaghetti dish of <code>if</code>, <code>elif</code> and <code>else</code> (or even <code>match/case</code> since Python 3.10).</p>"},{"location":"why/#after-arta","title":"After Arta","text":"<p>Arta increases rules maintainability:</p> <ul> <li>By standardizing the definition of a rule. All rules are configured or defined the same way in a unique place (or few).</li> <li>Rules are released from the code base, which is less error prone and increases clearness.</li> </ul> <p>Improve collaboration</p> <p>Reading python code vs reading YAML.</p>"},{"location":"assets/js/tarteaucitron/","title":"Index","text":""},{"location":"assets/js/tarteaucitron/#tarteaucitronjs","title":"tarteaucitron.js","text":"<p>Comply to the european cookie law is simple with the french tarte au citron.</p>"},{"location":"assets/js/tarteaucitron/#what-is-this-script","title":"What is this script?","text":"<p>The european cookie law regulates the management of cookies and you should ask your visitors their consent before exposing them to third party services.</p> <p>Clearly this script will: - Disable all services by default, - Display a banner on the first page view and a small one on other pages, - Display a panel to allow or deny each services one by one, - Activate services on the second page view if not denied, - Store the consent in a cookie for 365 days.</p> <p>Bonus: - Load service when user click on Allow (without reload of the page), - Incorporate a fallback system (display a link instead of social button and a static banner instead of advertising).</p>"},{"location":"assets/js/tarteaucitron/#supported-services","title":"Supported services","text":"<ul> <li>Advertising network</li> <li>Amazon</li> <li>Clicmanager</li> <li>Criteo</li> <li>FERank (pub)</li> <li>Google Adsense</li> <li>Google Adsense Search (form)</li> <li>Google Adsense Search (result)</li> <li>Google Adwords (conversion)</li> <li>Google Adwords (remarketing)</li> <li>Pubdirecte</li> <li>Twenga</li> <li> <p>vShop</p> </li> <li> <p>APIs</p> </li> <li>Google jsapi</li> <li>Google Maps</li> <li>Google Tag Manager</li> <li>Timeline JS</li> <li> <p>Typekit (adobe)</p> </li> <li> <p>Audience measurement</p> </li> <li>Alexa</li> <li>Clicky</li> <li>Crazyegg</li> <li>FERank</li> <li>Get+</li> <li>Google Analytics (ga.js)</li> <li>Google Analytics (universal)</li> <li>StatCounter</li> <li>VisualRevenue</li> <li> <p>Xiti</p> </li> <li> <p>Comment</p> </li> <li>Disqus</li> <li> <p>Facebook (commentaire)</p> </li> <li> <p>Social network</p> </li> <li>AddThis</li> <li>AddToAny (feed)</li> <li>AddToAny (share)</li> <li>eKomi</li> <li>Facebook</li> <li>Facebook (like box)</li> <li>Google+</li> <li>Google+ (badge)</li> <li>Linkedin</li> <li>Pinterest</li> <li>Shareaholic</li> <li>ShareThis</li> <li>Twitter</li> <li>Twitter (cards)</li> <li> <p>Twitter (timelines)</p> </li> <li> <p>Support</p> </li> <li>UserVoice</li> <li> <p>Zopim</p> </li> <li> <p>Video</p> </li> <li>Calameo</li> <li>Dailymotion</li> <li>Prezi</li> <li>SlideShare</li> <li>Vimeo</li> <li>YouTube</li> </ul>"},{"location":"assets/js/tarteaucitron/#visitors-outside-the-eu","title":"Visitors outside the EU","text":"<p>In PHP for example, you can bypass all the script by setting this var <code>tarteaucitron.user.bypass = true;</code> if the visitor is not in the EU.</p>"},{"location":"assets/js/tarteaucitron/#tested-on","title":"Tested on","text":"<ul> <li>IE 6+</li> <li>FF 3+</li> <li>Safari 4+</li> <li>Chrome 14+</li> <li>Opera 10+</li> </ul>"},{"location":"assets/js/tarteaucitron/#installation-guide","title":"Installation guide","text":"<p>Visit opt-out.ferank.eu</p>"}]}